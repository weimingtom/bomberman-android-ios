\subsection{G√©n√©ral}
	Le fait de d√©velopper des applications \gls{ios} et \gls{android}, nous a impos√© le choix du langage. En effet pour d√©velopper des applications \gls{iphone}, il faut utiliser le langage \gls{objective-c}, puis  pour les applications \gls{android} c'est le langage \gls{java} qui est utilis√©. C'est deux langages ont une syntaxe compl√©tement diff√©rente mais sont quand m√™me tr√®s proche car ce sont des langages orient√©s objets. Gr√¢ce √† cela nous avons pu mettre au point une mod√©lisation g√©n√©rale de l'application que nous avons ensuite adapt√© √† chaque langage.\\
			
	Nous avons d√©cid√© de d√©velopper en anglais car premi√®rement c'est la langue la plus utilis√© dans le monde de la programmation et deuxi√®mement car la syntaxe des langages est toujours en anglais. Cela permettra √† n'importe quel utilisateur de n'importe quelle nationalit√© de comprendre le code de l'application.\\
			
	La documentation des deux applications est √©galement en anglais. Cette documentation permettra √† tout utilisateur de comprendre le fonctionnement de l'application.
	Nous avons cr√©√© une documentation pour l'application \gls{iphone} et pour l'application \gls{android}. Chacune de ces documentations est au format \gls{html} et sera donc directement visible gr√¢ce √† un navigateur Web.\\
			
	Pour ce qui est de la mod√©lisation globale du projet, nous avons choisi de d√©velopper les deux applications selon le mod√®le \gls{mvc}. Ce dernier est une architecture et une m√©thode de conception qui organise l'\gls{ihm} d'une application logicielle. 
			
	Le mod√®le repr√©sente le comportement de l'application : traitements des donn√©es, interactions avec la base de donn√©es, etc. Il d√©crit et contient les donn√©es manipul√©es par l'application. Il assure la gestion de ces donn√©es et garantit leur int√©grit√©.
			
	La vue correspond √† l'interface avec laquelle l'utilisateur interagit. Sa premi√®re t√¢che est de pr√©senter les r√©sultats renvoy√©s par le mod√®le. Sa seconde t√¢che est de recevoir toutes les actions de l'utilisateur (clic de souris, s√©lection d'une entr√©e, boutons, etc).
			
	Le contr√¥leur prend en charge la gestion des √©v√©nements de synchronisation pour mettre √† jour la vue ou le mod√®le et les synchroniser. Il re√ßoit tous les √©v√©nements de l'utilisateur et enclenche les actions √† effectuer.
			
	Gr√¢ce √† cette m√©thode de conception le code est d√©compos√© en trois parties bien distinctes qui permettent la maintenance et l'am√©lioration du projet. Cela permet aussi de modifier chacune des trois parties sans avoir √† modifier les deux autres. Cela permet par exemple de changer de vue et avoir des interfaces graphiques diff√©rentes.
			
\subsection{Menus}

	Au d√©marrage de l'application vous arrivez sur un menu d'accueil. Depuis
	celui-ci vous pourrez acc√©der √† l'aide, √† la liste des comptes locaux ou √† la
	cr√©ation d'un nouveau compte local.
	Les menus de l'application ont √©t√© r√©alis√©s pour que l'utilisateur puisse les utiliser de mani√®re intuitive. Ils se divisent en quatre grandes sections.
		
	Vous avez tout d'abord la section de cr√©ation de parties locales. Vous aurez
	acc√®s √† une liste de cartes ainsi qu'au r√©glage de difficult√© des \glspl{bot}, leur
	nombre et le temps de jeu. Le type de partie sera une fonctionnalit√© √† venir.
	Vous n'aurez plus qu'√† cr√©er la partie configur√©e.
		
	Dans la m√™me cat√©gorie se trouve la section des parties multijoueurs. En
	acc√©dant √† celle-ci vous allez pouvoir vous connecter √† votre compte
	multijoueur, ou le cr√©er s'il n'est pas d√©j√† fait. Vous acc√®derez ensuite √† la liste
	des parties multijoueurs, que vous pourrez rejoindre, ou choisir de cr√©er la
	votre. Dans le menu cr√©ation le principe est proche des parties locales.
		
	Suite √† ces deux sections vient ensuite l'√©diteur de cartes. C'est depuis ce
	menu que vous cr√©erez une nouvelle map de jeu local ou √©diterez l'une d'entre elles. Choisisez votre nom de carte et l'√©diteur
	s'ouvrira ensuite √† vous. Il vous sera possible, √† la fin, d'enregistrer votre
	carte si vous d√©sirez la conserver et l'utiliser comme carte de jeu.
		
	Et enfin vient le menu des options. Depuis ce dernier vous pourrez g√©rer vos
	pr√©f√©rences syt√®mes telles que le volume ou la langue de
	l'application(anglais, fran√ßais).
	Une sous-section de gestionnaire de profil est aussi pr√©sente. Une √©dition de vos comptes locaux, multijoueurs ou m√™me
	vos param√®tres de jeu comme la position du menu, sont modifiable depuis ce
	menu √† onglets.
	
	\begin{figure}
		\label{activit√©}
		\includegraphics[width=23cm, angle=90]{Analyse/Img/diag_activity.eps}
		\caption{Diagramme d'activit√©}
	\end{figure}

	\paragraph{Base de donn√©es\\}
			
		Une base de donn√©es locale a elle aussi √©t√© con√ßue. Cette derni√®re a pour
		but de stocker plusieurs types de donn√©es.
				
		En effet d√®s lors qu'un compte local est cr√©√© sur le t√©l√©phone dans la
		table PlayerAccount, il est possible de conserver ses pr√©f√©rences de joueur
		tel que la couleur du joueur, le pseudonyme ou m√™me ses param√®tres de connexion multijoueur. 
		Vous pourrez cr√©er autant de comptes locaux que vous d√©sirez, et il
		sera possible possible d'√©diter ou choisir son compte.
				
		L'application est par ailleur en mesure de conserver
		les valeurs sonores, la langue et m√™me le dernier utilisateur de
		l'application, gr√¢ce √† un son id qui est cl√© √©trang√®re dans la table System(attribut lastUser).
				
		De plus l'application sera d√©livr√©e avec quelques cartes officielles, mais
		l'utilisateur aura libre droit de cr√©er ses propres cartes de jeu via un
		√©diteur. Elles seront alors stock√©es dans la table Map avec toujours une
		cl√© √©trang√®re vers l'id de son cr√©ateur(owner). \\
		
		\newpage
				
		\begin{figure}
			\includegraphics[width=11cm]{./Analyse/Img/menu_bdd.eps}
			\caption{Diagramme de classe Base de donn√©es}
		\end{figure}
		
		
		
						
	\paragraph{Sc√©narios}
	
	
\subsection{Editeur de carte}	

	L'√©diteur de carte est une fonctionnalit√© qui va permettre √† un utilisateur de cr√©er facilement ses propres cartes pour ensuite y jouer dessus contre l'int√©ligence artificielle. Apr√®s avoir r√©fl√©chi sur toutes les fonctionnalit√©s que l'√©diteur de carte devait remplir, nous avons retenu celles-ci : permettre √† l'utilisateur de cr√©er une nouvelle carte, mais aussi de charger une ancienne carte pr√©c√®demment cr√©√©e. Ensuite lui donner la possibilit√© de modifier le sol de la carte et aussi ajouter ou supprimer des blocs de la carte et enfin la derni√®re fonctionnalit√© que l'√©diteur de carte impl√©mente c'est de pouvoir placer les diff√©rents points de d√©part des joueurs sur la carte.
		
	Pour r√©aliser cette partie de l'application, nous avons utilis√© le mod√®le de conception MVC pour diviser le code de l'√©diteur de carte. Gr√¢ce a cette d√©composition, le code est plus lisible et plus facile √† r√©utiliser. 
			
	\subsubsection*{Mod√®le}
		La partie mod√®le va contenir toute les donn√©es de l'√©diteur de carte. Les cartes sont les principales donn√©es qu'il va devoir manipuler. Pour cela nous avons d√©cid√© de la r√©pr√©senter sous la forme de deux matrices, la premi√®re repr√©sentant les objets du premier niveau (le sol) et la deusi√®me la matrice du second niveau (les blocs, les points de d√©part des joueurs, etc).
			
			
	\subsubsection*{Vue}
		Ensuite, la vue repr√©sentera l'interface graphique de notre √©diteur de carte. La principale difficult√© pour r√©aliser l'interface graphique √©tait de devoir rentrer toutes les informations n√©cessaires pour l'√©diteur de carte dans un √©cran de type smartphone \footnote{Traduit litt√©ralement comme \og t√©l√©phone int√©ligent \fg \, en fran√ßais, c'est un terme utilis√© pour d√©signer les t√©l√©phones √©volu√©s, qui poss√®dent des fonctions similaires √† celles des assistants personnels. Certains peuvent lire des vid√©os, des MP3 et se voir ajouter des programmes sp√©cifiques.}. Apr√®s plusieurs prototypes d'interface, nous avons d√©cide de s√©parer l'interface en trois parties. Tout d'abord la plus grande partie, l'affichage de la carte, qui comment √©tant la principale information √† afficher, nous avons essay√© de maximiser sa taille. Ensuite un menu √† droite permettant au joueur de changer d'outil. Et la derni√®re partie affiche les diff√©rents √©l√©ments permettant de controler l'√©diteur de carte. L'utilisateur aura juste √† choisir l'outil qu'il veut placer sur la carte gr√¢ce au menu de droite et ensuite lui suffira d'appuier sur la carte pour placer un bloc dessus.
		
%		\begin{figure}
			\begin{center}
				\includegraphics[width=11cm]{./Analyse/Img/14-Editeur_de_niveau.eps}
			\end{center} 
%		 	\caption{Poulpy est multicolore}
%		 	\label{Poulpy est multicolore}
%		\end{figure}
			
			
	\subsubsection*{Controleur}
		Pour finir le controleur aurra pour but de faire la liaison entre les donn√©es du mod√®le et de la vue. Chaque vue poss√®de son controleur, et il y a un controleur gobal poss√©dant les controleurs de chaque vue.
			

\subsection{Jeu}
	\subsubsection{Intelligence artificielle}
		Comme nous avons vu dans le cahier des charges, nous avons mis en place une integellence artificielle permettant √† un joueur de jouer en solotaire.
	
		Tout d'abord nous avons du r√©fl√©chir √† toutes les actions que les bots pourraient effectuer, lors d'une partie. Premi√®rement l'action la plus importante que l'intelligence artificielle doit savoir faire c'est de pouvoir se d√©placer librement sur la carte en fonction des diff√©rents √©lements de la carte et des actions effectu√©es par les autres joueurs. Elles sont notamment capable de suivre le joueur le plus proche pour l'attaquer, fuire en cas de danger.  Ensuite les bots sont capables de d√©truire des murs pour pouvoir atteindre un point de la carte et  de poser une bombe pour essayer de tuer un ennimi.
	
		Comme nous veunos de le voir, la principale action que l'int√©lligence artificielle doit √™tre capable effectuer, c'est de pouvoir se d√©placer dans son environement. C'est pour cela que nous avons regard√© comment d√©placer un object dans un graphe, et nous avons trouv√© plusieurs algorithmes √©tant capable de rechercher un chemin dans un graphe, mais parmi tous ces algorithmes, nous en avons retenu deux en particul√©.
		
		\paragraph{Pathfinding}
		
		\subparagraph{A*\\}
		
			Tout d'abord l'algorithme de recherche A* a pour but de rechercher un chemin
			dans un graphe entre un n≈ìud initial et un n≈ìud final tous deux pr√©alablement
			d√©finis. A* permet de trouver l'un des meilleurs (mais pas forc√©ment le
			meilleur) chemins existant entre un point A et un point B (il retourne le premier chemin trouv√©). La force de cette algorithme est le temps de calcul et l'exactitude des r√©sultats, contrairement √† Dijkstra qui est le deuxi√®me algorithme que nous avons retenu qui lui fournit toujours le meilleur r√©sultat (le plus court chemin entre deux points) mais dans un temps d'ex√©cution beaucoup plus long que l'algorithme de A*. Et comme il peut y avoir jusqu'√† trois bots \footnote{Bot (diminutif de robot) d√©signe un personnage contr√¥l√© par l'ordinateur.} et que l'intelligence artificielle doit r√©guli√®rement recalculer son chemin en fonction des actions effectu√©es par les autres joueurs, nous avons donc choisi l'algorithme de A*.
		
			Maintenant que l'on sait quel algorithme utiliser pour rechercher un chemin dans un graphe, nous allons voir en d√©tail comment marche l'algorithme de A*.
		
			Pour comprendre comment l'algorithme marche, nous allons nous aider d'un
			dessin repr√©sentent une carte avec un point A (d√©part) affich√© en vert, un
			point B (arriv√©e) en rouge, et o√π les cases en bleu repr√©sentent les murs.
		
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille.eps}
			\end{center}
		
			La premier chose que l'on peut observer, c'est que la carte est divis√©e en
			cases. Chaque case de la matrice repr√©sente un node qui peut √™tre soit
			traversable, soit non traversable. Dans l'application, il n'y a que les murs
			ou les bombes que l'on ne peut pas traverser sinon tous les autres objets
			ou joueurs sont traversables. Le but de l'algorithme est donc de
			trouver un chemin entre A et B en √©vitant les murs.
			
		
			Durant le d√©roulement de l'algorithme, nous avons utilis√© deux listes qui contiennent des cases de la carte.
			Il y a une liste dite \og listeOuverte \fg \, et l'autre \og listeFerm√©e \fg.
			La listeOuvrete contient une liste de cases qui pourraient √©ventuellement faire partie du chemin, mais pas forc√©ment, pour le moment elle sera vide.
			Plus pr√©cis√©ment c'est une liste de cases que nous devons v√©rifier.
			Ensuite, au niveau de la listeFerm√©e, elle contient toutes les cases que nous
			aurons d√©j√† v√©rifi√©es, au d√©but de l'excution, elle contient que le point de d√©part (B3).
			
		
			Commencons les explications du d√©roulement de l'algorithme.
			Tout d'abord, il faut savoir qu'un joueur peut se d√©placer dans toutes les
			directions, donc nous allons ajouter toutes les cases adjacentes √† la
			listeOuvert qui sont traversables, il y en a huit (A2, B2, C2, A3, C3, A4, B4, C4).
			
			
			Ce qui nous donne :
		
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille2.eps}
			\end{center}
		
			Les carr√©s avec un contour rouge sont les carr√©s pr√©sents dans la
			listeOuverte et les carr√©s qui ont une couleur un peu plus fonc√©e que les
			autres sont ceux qui se trouvent dans la listeFerm√©e.
		
			Maintenant pour choisir la case par laquelle on doit passer, nous devons rajouter trois donn√©es \og F \fg , \og G \fg \, et \og H \fg:
			\begin{description}
				\item[G : ]{c'est le co√ªt de mouvement pour aller de la case A √† une case donn√©e sur la grille, en suivant le chemin g√©n√©r√© jusqu'√† cette derni√®re.}
				\item[H :]{c'est l'heuristique, c'est √† dire le co√ªt estim√© pour all√© du point courant √† l'arriv√©. Comme nous ne connaissons pas vraiment la distance qu'il nous reste √† parcourir, car toutes sortes d'obstacle peuvent se trouver sur notre chemin (objet non traversable). Donc nous allons devoir l'approximer gr√¢ce √† une fonction, pour la calculer nous avons choisi d'utiliser l'heuristique de Manhattan, qui consiste √† compter le nombre de bloc (√† vol d'oiseau et sans prendre les diagonales) qui lui reste √† parcourir.}
				\item[F :]{c'est G + H}
			\end{description} 
		
			Chaque case de la listeOuverte ou de la listeFerm√©e vont devoir poss√®der toutes ces donn√©es, plus les coordonn√©es de leur p√®re, c'est √† dire les coordonn√©es de la case qui vient de les ajouter dans la la listeOuverte. Pour calculer G, nous allons assigner un co√ªt de 10 pour chaque d√©placement horizontal ou vertical, et un co√ªt de 14 pour un mouvement en diagonale. Nous utilisons ces donn√©es car la distance n√©cessaire pour se d√©placer est la racine carr√©e de 2, ou approximativement 1.41 fois le co√ªt d'un d√©placement vertical ou horizontal. Nous utiliserons donc 10 et 14 pour des raisons de simplification. Par cons√©quent, nous allons multiplier par 10 le co√ªt H pour qu'il soit coh√©rent par rapport √† G.
	
			Donc maintenant, nous devons avoir cette matrice :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille3.eps}
			\end{center}
		
			Apr√®s avoir ajout√© toutes les cases adjacentes √† la case courant, il suffit de prendre la case qui a le plus petit co√ªt F et ensuite de la rajouter dans la listeFerm√©e et de la supprimer de la listeOuverte. Nous obtenons donc :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille4.eps}
			\end{center}
		
			Ensuite on regarde toutes les cases adjacentes √† la derni√®re case ajout√©e dans la listeFerm√©e. Si elles se trouvent d√©j√† dans la listeOuverte, on v√©rifit que leurs co√ªt soient inf√©rieur au co√ªt de la case correspondante d√©j√† dans la listeOuverte, si oui alors on la remplace sinon on ne fait rien.
		
			Pour finir on r√©p√®te cette op√©ration jusqu'on arrive √† la case d'arriv√©e, nous obtenons √ßa :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille5.eps}
			\end{center}
		
			Pour finir, il nous suffit juste de r√©cup√©rer la case d'arriv√©e et de regarder son p√®re, puis de rep√©ter cette op√©ration avec la case obtenu jusqu'√† arriver √† la case de d√©pard. Gr√¢ce √† √ßa nous obtenons cette derni√®re √©tape de l'algorithme :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille6.eps}
			\end{center}
		
			Comme on peut le voir sur le sch√©ma pr√®d√©dent, le chemin qu'√† trouv√© l'algorithme de A* est le suivant : $ B3 \rightarrow C4 \rightarrow C5 \rightarrow D5 \rightarrow E5 \rightarrow F4 \rightarrow F3 $. L'algorithme aurait pu d'autre chemin √©quivalent √† celui-ci mais le principe de cette algorithme c'est de renvoyer le permier chemin qu'il trouve.
		
		\subparagraph{Parcours en largeur\\}
		
			Contrairement √† l'\gls{algorithme} A*, le parcours en largeur se contente d'un
			n≈ìud initial mais ne n√©cessite pas un n≈ìud final.
			En effet ici nous allons partir d'un point et chercher le premier point
			correspondant √† nos attentes, pour cela nous effectuerons donc un parcours un
			largeur.
			
			Le parcours en largeur consiste √† partir d'un sommet S, lister d'abord
			tous les voisins de S pour ensuite les explorer un par un.
			Ici nous allons donc regarder toutes les cases autour de nous puis regarder
			tous leurs voisins et cela ainsi de suite jusqu'√† trouver un point
			correspondant √† nos attentes.
			
			Le contexte est le suivant, un \gls{bot} d√©couvre qu'il est sur la trajectoire
			d'explosion d'une bombe est va donc fuir vers la case s√ªr la plus proche or
			il n'a aucune id√©e d'o√π elle se trouve.
			
			L'image suivante repr√©sentera la situation initiale :
			
			\begin{center}
				\includegraphics[width=115mm,height=71mm]{./Analyse/Img/fuite1.eps}
			\end{center}
			
			Comme dit pr√©c√©demment il n'y a que les murs ou les bombes que l'on ne peut
			pas traverser sinon tous les autres objets ou joueurs sont traversables.
			Nous considerons que les bombes ont ici un champs d'explosion en nombre de
			cases de 5.			
			
			Repr√©sentons la carte ci-dessus d'une fa√ßon plus parlante en remplacant les
			divers objets mis √† par le joueur par des num√©ros leur correspondant, √†
			savoir :
			
			\begin{enumerate}
			  \item Les zones dites dangeureuses donc ici le champs d'explosion de la
			  bombe.
			  \item Toutes les cases infranchissables telles que les murs ou encore les
			  bombes
			\end{enumerate}
			
			Ce qui nous donne :
			
			\begin{center}
				\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \hline
				\rowcolor{cyan} 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 \\\hline
				\cellcolor{cyan}2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & \cellcolor{cyan}\cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 &
				0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 \\\hline \cellcolor{cyan}2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{red}1 & \cellcolor{cyan}2 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{red}1 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{red}1 &	\cellcolor{gray}2 & \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{red}1 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{red}1 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}2 & \cellcolor{gray}2 & \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{red}1 & 0 &	0 & \cellcolor{cyan}2 \\\hline 
				\cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}2 \\\hline
				\cellcolor{cyan}2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}2 \\\hline
				\rowcolor{cyan}2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 \\\hline
				\end{tabular}
			\end{center}
			
			Mettons nous √† present √† la place du \gls{bot}.
			
			Nous allons donner un poid aux cases que nous allons parcourir
			correspondant √† la distance par rapport √† la case initiale, ainsi qu'une
			direction qui correspondra √† la direction initiale que le \gls{bot} devra empruter
			pour utiliser ce chemin, c'est √† dire par exemple que tout chemin d√©couvert
			dont l'origine est une case √† droite de la notre aura comme direction droite.
			
			A partir d'une case donn√©e, nous ne regarderons que les voisines ayant un poids de 0
			car si leur poids est diff√©rent cela voudra dire que nous les avons d√©j√† vu precedemment et bien √©videmment,
			nous ignorerons les murs ainsi que les bombes.
			
			Nous avons chang√© la valeur des cases intraversables pour ne pas confondre avec le poids des cases visit√©es.			
			
			Appliquons l'algorithme de parcours en largeur aux cases voisines de la notre.
			
			
			\begin{center}
				\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \hline
				\rowcolor{cyan} X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X &0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{orange}1 $\uparrow$ & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{orange}1 $\leftarrow$ & \cellcolor{orange}1 & \cellcolor{gray}X & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{orange}1 $\downarrow$ & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X & \cellcolor{gray}X & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &
				\cellcolor{cyan}X \\\hline \rowcolor{cyan}X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X \\\hline
				\end{tabular}
			\end{center}
			
			
			Toutes les cases d√©couvertes √©tant consid√©r√©es comme dangereuses (voir le sch√©ma pr√©c√©dent) nous continuons √† appliquer l'\gls{algorithme} jusqu'√† arriver √† notre but.
			
			\begin{center}
				\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \hline
				\rowcolor{cyan} X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X &	0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{orange}2 $\uparrow$ & \cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}2 & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{orange}1 $\uparrow$ & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{orange}2 $\leftarrow$ & \cellcolor{orange}1 $\leftarrow$ & \cellcolor{orange}1 & \cellcolor{gray}X & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{orange}1 $\downarrow$ & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X & \cellcolor{gray}X & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &
				\cellcolor{cyan}X \\\hline \rowcolor{cyan}X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X \\\hline
				\end{tabular}
			\end{center}
			
			
			\begin{center}
				\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \hline
				\rowcolor{cyan} X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X &	0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{green}3 $\uparrow$ & \cellcolor{orange}2 $\uparrow$ & \cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{orange}1 $\uparrow$ & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{orange}3 $\leftarrow$ & \cellcolor{orange}2 $\leftarrow$ & \cellcolor{orange}1 $\leftarrow$ & \cellcolor{orange}1 & \cellcolor{gray}X & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{orange}1 $\downarrow$ & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X & \cellcolor{gray}X & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & \cellcolor{cyan}X & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X & 0 & \cellcolor{cyan}X \\\hline
				\cellcolor{cyan}X & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &
				\cellcolor{cyan}X \\\hline \rowcolor{cyan}X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X \\\hline
				\end{tabular}
			\end{center}
			
			Ici nous avons d√©couvert une case non dangeureuse en $(13,6)$ !
			Nous r√©cup√©rons donc la direction enregistr√©e dans cette case et bougeons en fonction de celle-ci.
			Si plusieurs cases avaient √©t√© d√©couvertes le choix aurait √©t√© arbitraire car elles auraient toutes √©t√© √† la m√™me distance.
			
			$\,$
			
	\begin{itemize}
		\item{Diagramme classe}
	\end{itemize}
	
	Comme vue dans le cahier des charges, l'application est divis√©e en trois grandes parties: le mod√®le, la vue et le contrôlleur.
	
	\subsubsection{Mod√®le}
	
	Le mod√®le constitue la \textit{base} de notre projet. C'est sur celui-ci que nous avons construit le reste de l'application. Nous avons mod√©lis√© celui-ci de mani√®re √† ce qu'il soit clair et simple. Ce dernier ce d√©compose en trois sous-partie: la partie hierarchie des objets, la partie moteur puis la partie √©diteur de carte.\\
	
	\paragraph{Hierarchie des objets \\}
	
	Pour concevoir la hierarchie des objets, il a fallu tout d'abord dinstinguer la totalit√© des objets qui seraient disponible dans le jeu ainsi que leurs diff√©rences et leur point communs.  Nous avons donc distingu√© quatre grands types d'objets: les objets destructibles, les objets indestructibles, les objet anim√©s ainsi que les objets inanim√©s. En sachant que les objets pouvaient √™tre destructibles-anim√©s, destructible-inanim√©s, indestructible-anim√©s ou indestructible-inanim√©s. Nous avons choisi que tout objet serait consid√©r√© comme un objet anim√© pour √©viter des soucis de mod√©lisation. Ainsi les objets poss√®deront tous une sequence d'animation d'images qui sera dessin√© a l'√©cran. Cette derniere sera r√©p√©t√© dans le cas d'une animation qui se r√©p√©t√© et qui comporte plusieurs images, sinon si elle poss√®de simplement qu'une seule image, seule cette image sera dessin√© a l'√©cran. Nous avons ensuite dinstingu√© une multitude de point communs entre les diff√©rents objets dont voici le nom de l'attribut et leur utilit√© : 
	
	\begin{description}
		\item [\textit{position}]{indique la position en pixel de l'objet sur l'√©cran}
		\item [\textit{nom}]{indique le nom de l'objet}
		\item [\textit{hit}]{est √† 1 si l'objet peut √™tre touch√© par une explosion (0, sinon)}
		\item [\textit{level}]{est √† 1 si l'objet est anim√©s (0,sinon)}
		\item [\textit{fireWall}]{est √† 1 si l'objet ne laisse pas passer les flammes des explosions (0,sinon)}
		\item [\textit{damages}]{indique si l'objet peut infliger des domages}
		\item [\textit{idle}]{est une image qui repr√©sente l'objet en g√©n√©ral}
		\item [\textit{animates}]{est une table de hachage contenant l'ensemble des images composant la sequence d'animation de l'objet (vide si inanim√©s)}
		\item [\textit{destroy}]{est une table de hachage contenant l'ensemble des images composant la sequence d'animation de destruction de l'objet (vide si indestructible)}
		\item [\textit{currentFrame}]{permet de connaitre le num√©ro de l'image courante de la sequence d'animation en cours d'affichage}
	\end{description}

	Nous avons donc d√©cider de concevoir une classe "Object"  pour mod√©liser toutes ces propri√©t√©s que les objets ont en commun. Cette classe sera abstraite car tout objet est destructible ou indestructible et cela sera d√©cris dans des classes plus sp√©cialis√©s.
	
	 Ensuite nous avons pens√© a cr√©er deux autres classes: "Destructible" et "Undestructible" pour les objets destructible et indestructible. Ces deux classes h√©ritent de "Object" car elles sont des objets. Ce qui diff√©rencie ces deux classes est le champ \textit{life} qui permet de savoir combien de fois l'objet doit etre touch√© par une bombe avant d'√™tre detruit.
	
	Nous avons ensuite dinstingu√© deux autres types d"objets encore plus sp√©cifique: Les joueurs et les bombes. Ces derniers sont des objets destructibles puisqu'il ne dure pas toute la partie selon le mode de jeu.
	
	Les bombes poss√®dent deuxnouveaux attributs qui les diff√©rentie des autres objets: 
	\begin{description}
		\item [\textit{type}]{permet de connaitre le type de bombe}
		\item [\textit{owner}]{permet de connaitre le joueur qui a pos√© la bombe}
	\end{description}
	
	Quand √† la classe joueur celle-ci poss√®de encore d'autres attributs: 
	\begin{description}
		\item [\textit{color}]{permet d'afficher √† l'√©cran le joueur avec sa bonne couleur}
		\item [\textit{bombsTypes}]{permet de connaitre le type de bombe qu'il peut poser}
		\item [\textit{powerExplosion}]{permet de connaitre la port√© d'explosion de ses bombes}
		\item [\textit{timeExplosion}]{permet de connaitre le temps d'explosion des bombes}
		\item [\textit{speed}]{permet de connaitre la vitesse du joueur}
		\item [\textit{shield}]{permet de connaitre la valeur du bouclier}
		\item [\textit{bombNumbers}]{permet de connaitre le nombre maximum de bombes que le joueur peut poser}
		\item [\textit{isTouched}]{permet de savoir si le joueur viens d'√™tre touch√©}
		\item [\textit{isKilled}]{permet de savoir si le joueur est mort}
		\item [\textit{isInvincible}]{permet de savoir si le joueur est invincible}
	\end{description}
	
	Cette hierarchie de classe nous permettra donc de mod√©liser l'ensemble des objets que le jeu pourra afficher.
	
	
	
	\paragraph{Moteur\\}
	
	Pour ce qui est du moteur. Celui-ci est repr√©sent√© par une classe "Engine". Cette classe va contenir l'ensemble des methodes qui vont permettre de d'√©tablir les collisions. C'est aussi cette classe qui s'occuppe de mettre √† jour les bombes ainsi que l'IA du jeu. 
	Une instance d'un moteur est associ√© √† une partie dont le nom de classe est "Game". Cette classe "Game" est abstraite et repr√©sente une partie avec toutes les options qu'elle contient. C'est √† dire qu'elle poss√®de des attributs permettant de d√©crire le type de partie, un tableau avec chaque joueur de la partie, ainsi que le carte du jeu. La classe poss√®de toutes les m√©thodes d'initialisation, de mise √† jour, de dessins et de fin de la partie. Enfin pour diff√©rencier les diff√©rents types de parties nous avons utiliser le pattern \footnote{Un pattern est un mod√®le de conception en informatique} d√©corateur. Ainsi il y aura deux grands types de parties: les parties solitaires et les parties multijoueurs. Puis ces parties sont d√©cor√©s par le type de partie: survivor \footnote{Le mode survivor est un mode o√π chaque joueur √† un nombre de vie limit√© et dont le gagnant est celui qui sera le dernier a √™tre en vie} ou death match\footnote{Le mode death match est un mode o√π il y a un temps limit√© et dont le joueur gagnant est celui qui a tu√© le plus d'ennemis}.
	
	Ensuite pour ce qui est des cartes, une classe abstraite nomm√© "Map" contient le nom et la taille de la carte ainsi qu'un tableau contenant la position initial de chaque joueur sur la carte. Puis une classe "GameMap" qui h√©rite de map permet de dessiner la carte a l'√©cran, elle se compose d'une image repr√©sentant le sol puis d'un tableau d'objets anim√©s qui permet de repr√©senter l'ensemble du reste des objets. Ensuite nous utilisons un autre type de carte qui va permettre de faciliter les collisions, que ce soit pour un joueur humain ou pour une intelligence artificielle. Cette classe est appel√© "CollisionMap" et contient une matrice d'objet "CollisionCase" ainsi qu'un tableau qui contient l'ensemble des bombes pos√©s sur la carte. Les "CollisionCase" sont compos√© de deux tableaux. Chaque valeur d'un des tableau est associ√© √† une valeur de l'autre talbeau. Un tableau \textit{types} contient les diff√©rents types de danger ou d'objet  qu'il existe sur cette case et un tableau \textit{counters} permettra en fonction de chaque type de compter le nombre de fois que ce danger ou objet est pr√©sent sur cette case. Par exemple on peut tr√®s bien avoir une case qui est dans le champ d'explosion de quatres bombes et qui contient un bloc de type destructible. Ainsi le tableau \textit{type} contiendra deux champs , un pour le type zone dangereuse et un autre pour le type bloc destructible puis le tableau \textit{counters} contiendra donc dans sa case associ√© √† la case zone dangereuse une valeur √©gale √† quatre et et une valeur de un pour l'autre. 
		
	
	\subsubsection{Vue}
	
	L'interface graphique du jeu est d√©compos√© en trois partie. Une partie qui repr√©sente le menu d'information de la partie, une autre qui r√©pr√©sente le menu des actions possibles du joueurs et une derni√®re qui repr√©sente la partie en cours. 
	Le menu d'information se situe en haut de l'√©cran. Il permet d'afficher le score des joueurs, le temps lors d'une partie death match ainsi que les bonus du joueurs (le nombre de bombes qu'il peut poser, la port√©e de l'explosion des bombes, la vitesse du joueur et les bonus de vie) et de mettre le jeu en pause.
	Le menu d'action se situe √† droite de l'√©cran. Il permet √† l'utilisateur de poser les bombes gr√¢ce √† un bouton et aussi de changer de type de bombes gr√¢ce √† une liste d√©roulante.
	Quand √† la partie, elle est afficher au centre de l'√©cran et prend le maximum de place possible pour que le jeu soit le plus visible possible. Elle permet d'afficher la carte ainsi que les joueurs et les bombes. Mais elle sert aussi √† √©couter les mouvements du doigt de l'utilisateur pour modifier les coordonn√©es du joueur dans le mod√®le pour pouvoir ensuite rafraichir l'√©cran et voir le joueur se deplacer.
	
	
	
	\subsubsection{Controlleur}
	
	Le controlleur va permettre de faire la liaison entre la vue et le mod√®le. La majorit√© de ces m√©thodes sont appel√© lorsque l'utilisateur interagie avec la vue. Ces m√©thodes vont par la suite modifier le mod√®le qui va permettre de mettre √† jour la vue. Le controlleur est divis√© en quatre sous-controlleur. Chacun des trois premiers est respectivement associ√© √† l'une des trois vues cit√© ci-dessus. Puis le quatri√®me est plus g√©n√©ral, il permet de faire la liaison entre les trois autres controlleurs. Car en effet chacune des actions effectu√©s sur l'une des  vue peut modifier l'une des deux autres.
	
	\subsubsection{GamePlay}
	Nous avons choisi d'√©tablir un gameplay immersif. C'est √† dire que notre interface graphique sera utilis√©e de mani√®re souple et intuitive. Notre gameplay est divis√© en trois parties: les d√©placements, la pose des bombes et la gestion des diff√©rents types de bombes.
		
		Pour ce qui est des d√©placements du joueurs. Nous avons d√©cid√© que l'utilisateur utiliserais toute la surface de l'√©cran pour se d√©placer. Ainsi si il veut se d√©placer vers la droite, il fait glisser sont doigt de la gauche vers la droite, puis tant qu'il restera appuyer sur l'√©cran, le joueur continura de se d√©placer. Cette mani√®re de se d√©placer est pr√©cise et tr√®s intuitive contrairement √† l'utilisation d'un joystick virtuel ou de l'acc√©l√©rom√®tre.
		
		Pour la pause des bombes un simple boutton est mis en √©vidence en bas √† droite de l'√©cran. Celui-ci est assez gros pour que l'utilisateur n'est pas √† appuyer sur une zone trop pr√©cise en cas de manipulation rapide.
		
		Puis pour le choix des diff√©rentes bombes, une simple liste d√©roulante est mise en √©vidence √† droite du jeu, pour pouvoir changer de bombe rapidement.\\
		
		\subsubsection{Tile Mapping}

		La gestion des images a √©t√© une partie tr√®s importante de l'analyse. Car le d√©veloppement mobile impose plusieurs contraintes, notament la gestion de la m√©moire et la vitesse de calcul. Nous nous sommes donc inspir√© des premiers jeux consoles comme Super Mario Bros ou Zelda qui ont √©t√© d√©velopp√© sur les premieres consoles comme la NES\footnote{La Nintendo Entertainment System, ou NES, est une console de jeux vid√©o 8 bits} ou la GameBoy\footnote{La Game Boy  est une console de jeux vid√©o portable √† la puissance comparable √† celle de la NES}. Nous avons donc con√ßu le moteur du jeu selon le principe du Tile Mapping\footnote{Le Tile Mapping est une technique de mod√©lisation graphique} pour minimiser l'utilisation des ressources des t√©l√©phones.
		
		Le principe du Tile Mapping est d'utiliser des petites images que nous appelerons \textit{tiles}. Ces tiles sont contenu dans une image appel√© sprite (cf ci-dessous).
		Ensuite une matrice de nombre entier est utilis√© pour repr√©senter l'environnement du jeu. Chaque nombre entier repr√©sente un tile. Puis gr√¢ce √† cette association, la carte sera dessin√© √† l'√©cran selon la matrice. Voici un exemple :
		
		\includegraphics[width=15cm]{./Analyse/Img/tileMapping.eps}
		
		
		Nous avons donc repris ce principe et nous l'avons am√©lior√©. En effet gr√¢ce √† la programmation objet, les entiers sont r√©pr√©sent√© directement par des objets contenant le tile qui le repr√©sente. Ainsi, nous stockons dans une matrice tous les objets inanim√©s (les objets dont le tile restera le meme tout le long de la partie) et nous parcourons cette matrice pour dessiner chaque objet √† sa position pour obtenir une nouvelle image au format png. Ainsi √† chaque rafraichissement de l'√©cran, seule la nouvelle image est dessin√© et non pas chaque tile. Cette m√©thode permet d'√©viter un parcours intempestif de la matrice.
		Ensuite pour le reste des objets (les objets anim√©s compos√©s d'une sequence de tiles) nous avons d√©cid√© de les stocker dans une table de hachage dont la cl√© est la position de l'objet (pour y acc√©der plus rapidement). Ainsi √† chaque rafraichissement de l'√©cran on va dessiner l'image des objets inanim√©s puis parcourir entierement la table de hachage et dessiner le tile courant de la sequence d'animation de chaque objet.
		
		\subsubsection{La gestion des images et du son}
		
		Chaque image, tile et chaque son dont est compos√© le jeu sont charg√© au lancement de l'application. Tous les tiles sont stock√© dans des images appel√©s sprites. Un sprite est donc un ensemble d'image. L'ensemble des tiles sont stock√©s dans diff√©rents sprites. Il y a un sprite pour les bombes, un pour les joueurs et un autre pour le reste des objets. Chaque sprite contient l'ensemble des images des objets qu'il repr√©sente. Chaque sprite est associ√© √† un fichier XML \footnote{ Extensible Markup Language, (langage de balisage extensible) est un langage informatique de balisage g√©n√©rique}. Le fichier XML peut √™tre r√©pr√©sent√© sous forme d'un arbre. Les fichiers XML ressemble tous plus au moins a ce genre d'arborescence: 
		
		\includegraphics[width=15cm]{./Analyse/Img/exampleXmlBomberklob.eps}
		
		Chaque fichier XML commence par une balise racine permettant de lister les objets qu'elle contient (\textit{<objects>}). Ensuite chaque objet est d√©cris par une balise  qui contient le type, le nom de l'objet ainsi que l'ensemble de ses propri√©t√©s. La propri√©t√© \textit{hit} est √† 1 si l'objet peut √™tre touch√© par une explosion (0, sinon), le champ \textit{level} est √† 1 si l'objet est anim√©s (0,sinon), le champ \textit{fireWall} est √† 1 si l'objet ne laisse pas passer les flammes des explosions, le champ \textit{life} indique le nombre de fois que l'objet doit etre touch√© par des flammes pour qu'il soit entierement d√©truit, et enfin le champ \textit{damages} indique si l'objet peut infliger des domages. Par exemple \textit{<destructible name="herb" hit="1" level="1" fireWall="1" life="1" damages="0">} d√©cris un objet de type \textit{destructible}, qui peut-etre touch√© par des flammes, qui est anim√©, ne laisse pas passer les flammes des bombes, possede une vie,  n'inflige pas de domage et dont le nom est \textit{herb} . Ensuite chaque objet poss√®de au plus trois balises animations (sauf pour les joueurs). Tout objet poss√®de au moins la premiere balise:  <animation name="idle" canLoop="false" sound="sound\_path"> qui est celle dont le nom est \textit{idle}. Elle repr√©sente l'image standard de l'objet. Par exemple pour un objet bombe, ce sera l'image qui sera affich√© dans la liste des bombes pour pouvoir selectionner ses bombes. Le champs \textit{canLoop} permet de savoir si l'image doit √™tre r√©p√©t√© en boucle et le champ \textit{sound} contient le chemin d'acces au fichier de son de l'animation si elle en possede un. Il y a ensuite la m√™me balise mais dont le nom est \textit{animate}, celle-ci contiendra toutes les sequences d'images d'un objet qui est anim√©s. Puis la derni√®re est celle dont le nom est \textit{destroy}. Cette derniere contiendra l'ensemble des images composant la sequences d'animation de destruction de l'objet. Enfin chaque balise de type animation contient des balises de type \textit{framerect}. Ces balises permettent de donner la position de chaque image de la s√©quence d'animation dans le sprite ainsi que le delay de rafraichissement entre chaque image. Par exemple \textit{<framerect top="60" left="30" bottom="90" right="60" delayNextFrame="1" />} repr√©sente une image dont le bord du haut est situ√© √† 30pixels, le bord du bas √† 90pixels, le bord de gauche √† 30pixels et le bord de droite √† 60pixels en partant du coin en haut √† gauche du sprite. Puis pour le champ \textit{delayNextFrame} celui-ci informe que l'image suivante sera d√©clench√© apres un delay de 1s.\\
		
		Gr√¢ce √† cette mod√©lisation, l'application va parcourir au d√©marrage l'ensemble des fichiers XML et va cr√©er une table de hachage pour chaque ensemble d'objet du fichier. Lors de ce parcours, l'application va instancier chaque objet avec toutes propri√©t√©s que lui indique le document XML, ainsi que ses sequences d'animation. Ensuite lorsqu'un objet devra √™tre utilis√© dans le jeu, il suffira d'utiliser une copie de l'objet d√©ja charg√© en m√©moire pour √©viter de devoir reparcourir le fichier.


\subsection{R√©seau}
		
	\paragraph{Serveur\\}
			
		Il a √©t√© fix√© dans le cahier des charges que notre serveur devrait pouvoir
		effectuer plusieurs t√¢ches particuli√®res s√©par√©es. Nous avons donc d√©cid√© de
		les compartimenter en classes.
		
		Notre serveur est cr√©e sur une base de servlet. Ce f√ªt ici
		aussi un point nouveau pour nous, r√©iterant les phases d'analyse, de
		d√©couverte, de test et de mise en place. Le fonctionnement est bas√© sur les
		√©changes de requ√™tes type HTTP, o√π √† chaque demande correspond une r√©ponse. 
		
		Une servlet est une classe Java qui permet de cr√©er dynamiquement des donn√©es
		au sein d'un serveur HTTP. Une servlet s'ex√©cute dynamiquement sur le serveur
		web et permet l'extension des fonctions de ce dernier, typiquement : acc√®s √†
		des bases de donn√©es.
			
		Les six √©l√©ments situ√©s sur la partie haute du sch√©ma
		ci-dessous(respectivement ServletInscription, ServletConnection,
		ServletGamesList, ServletCreateGame, ServletConnectionGame et
		ServletManageGame), repr√©sente les diff√©rentes t√¢ches qu'un utilisateur
		puisse demander au serveur. Elles sont reli√©es √† une classe nomm√©e
		ContextListener, qui leur permettra d'acc√©der aux m√™mes donn√©es sans qu'il y
		ait de conflits. La partie basse repr√©sente les objets qui seront utilis√©s pour les parties en multijoueurs. 
		Bien √©videmment ces objets sont tr√®s proches de ceux utilis√©s dans les parties
		locales(Sch√©ma 3.3).
		
		
		Comme il a √©t√© dit pr√©c√©dement, notre serveur est accessible via des requ√™tes
		HTTP contactant des servlets. Ces servlets sont stock√©es dans un serveur
		d'application nomm√© Apache Tomcat. Il s'agit d'un conteneur libre de
		servlets Java 2 Enterprise Edition, mais il fait aussi office de serveur
		Web.\\
		
		
		Le sc√©narios le plus probable serait le suivant. Un utilisateur d√©sire jouer
		en ligne contre de vrais joueurs. 
		Il va alors passer par l'inscription et cr√©er son compte sur le
		serveur(Inscription). Une fois cette √©tape obligatoire faite, il pourra
		choisir entre rejoindre une partie en ligne en cour(ConnectionGame), ou en
		cr√©er un nouvelle(CreateGame). D√®s lors qu'il aura acc√®s √† une partie en
		ligne, un contact r√©gulier avec le serveur sera obligatoire afin de r√©aliser
		les interactions entre les diff√©rents joueurs(ManageGame). Tout ceci devra se
		r√©aliser bien s√ªr dans une dur√©e infime afin de ne pas p√©naliser les joueurs.	
		
		\begin{figure}
			\includegraphics[scale = 0.5]{Analyse/Img/serveur.eps}
			 \caption {Serveur}
		\end{figure}
		
		\newpage
		
		
	\paragraph{JSON\\}	
		Soucieux des performances et de la rapidit√© des √©changes entre applications et
		serveur, nous avons mis en place un protocole de communication client/serveur
		o√π les messages transitant sont des flux JSON\footnote{JavaScript Object
		Notation :  format de donn√©es textuel issu du JavaScript (ECMAScript pour plus
		exact) o√π il √©tait employ√© comme une syntaxe pour d√©crire les valeurs des
		instances d‚Äôobjets}. 	
		Contrairement au XML qui peut repr√©senter des donn√©es orient√©es document,
		JSON se focalise sur la description d‚Äôobjets.
		Un autre avantage reconnu de JSON par rapport √† XML est qu‚Äôil est nettement
		moins verbeux que ce dernier.
		Quoi qu‚Äôil en soit JSON reconnait la philosophie des services web exposant
		une interface d‚Äô√©change : il s‚Äôagit
		d‚Äôenvoyer et de recevoir des informations dans un format facilement manipulable par
		le protocole de transport HTTP.
		
		
		Voil√† pourquoi le JSON semblait √™tre un format de donn√©es d'√©changes optimal
		pour v√©hiculer le plus d'informations avec une taille moindre. Il est aussi en
		ad√©quation avec notre politique d'utilisation web pour un serveur.
		De plus √©tant beaucoup utilis√©, nos deux
		langages mettent √† disposition des outils de s√©rialisation de leurs objets en JSON.
		
		Ci-dessous un exemple concret de notre protocole de communication JSON entre
		serveur et application cliente.
		
			
		\begin{verbatim}
			ServletInscription
				Player => Serveur
				{["username","password"]}
				
				Serveur => Player
				{"OK"} ou {"BU"}
				
			ServletConnexion 	
				Player => Serveur
				{["username","password"]}
				
				Serveur => Player
				{"OK"} ou {"BU"}
				
			ServletGameList
				Player => Serveur
				{"userKey"}
			
				Serveur => Player
				{[{"class":"Game","map":"mapName","name":"gameName",
				 "playerNumberConnected":nbConnected,"type":"gameType"},{..},{..}]}
				 
			ServletCreateGame:
				Player => Server:
					{"userKey": <userKey>, 
					"game": {"name":<name>, "type":<type>, "map":<map>, "ennemiesNumber": <ennemiesNumber>}}
					
				Server => Player:
					{"OK"} ou {"errorType"}
				 
			ServletConnectionGame:
				Player => Server:
					{["userKey", "gameName"]}
					
				Server => Player:
					{[<1/2/3/4>, "play<true/false>", "map", "time<mm:ss>"]} 
					ou 
					{"errorType"}
					
			ServletManageGame:
				Player => Server: 
					{"userKey", "gameName", "action"}	
					
				Server => Players: (Player, bombs, blocs, score, time)
					{[
					 [ ["x", "y", "direction", "dead <true/false>"],[...] ],
					 [ ["x", "y", "type", "explode <true/false>" ], [...] ],
					 [ ["position": {"x", "y"}, "bonus": <bonus>], [..] ],
					 [1,2,3,4],
					 "time <mm:ss>"]} 
					 ou 
					{"errorType"}
				 
				 
		\end{verbatim}
			
		
	

	\subsubsection{Sch√©ma de fonctionnement }
		
		\begin{center}
			\includegraphics[width=16cm]{Analyse/Img/serveurappli.eps}
		\end{center}
		
		\begin{enumerate}

			\item 
					Le client √©met une requ√™te pour demander une
					ressource au serveur. Par exemple la cr√©ation de son compte multijoueur,
					qui pourrait se situer \url{http://Bomberklob.com/inscription}
			\item
					C√¥t√© serveur, c'est le serveur web qui traite les
					requ√™tes HTTP entrantes. Il traite donc toutes les requ√™tes, qu'elles
					demandent une ressource statique ou dynamique. Seulement, un serveur HTTP
					ne sait r√©pondre qu'aux requ√™tes visant des ressources statiques.

			\item 
					Ainsi, si le serveur HTTP s'aper√ßoit que la requ√™te re√ßue est destin√©e
					au serveur d'applications, il la lui transmet. Les deux serveurs sont
					reli√©s par un canal, nomm√© connecteur.
		
			\item
					Le serveur d'applications (dans notre cas Tomcat) re√ßoit la requ√™te √†
					son tour. Lui est en mesure de la traiter. Il ex√©cute donc la servlet
					correspondante √† la requ√™te, en fonction de l'URL, en r√©cup√©rant les
					valeurs dans le flux JSON entrant. Cette op√©ration est effectu√©e √† partir
					de la configuration du serveur, gr√¢ce un fichier web.xml faisant le mapping
					entre URL et servlet associ√©e.
		
					La servlet est donc invoqu√©e, et le serveur lui fournit notamment deux
					objets Java exploitables: un repr√©sentant la requ√™te, l'autre repr√©sentant
					la r√©ponse. La servlet execute sa fonction et g√©n√®re la r√©ponse √† la
					demande, sous forme de flux JSON. Cela peut passer par la consultation de
					sources de donn√©es, comme des bases de donn√©es (4' sur le sch√©ma).		
		
		\end{enumerate}
		
	\paragraph{Base de donn√©es\\}
		Afin de pouvoir conserver les utilisateurs en ligne ainsi que leurs infos
		personnels et permettre une authentification, nous avons d√ª √©tablir une
		base de donn√©es sur le serveur. Cette derni√®re √† √©t√© pens√© comme demand√© pour 
		l'enregistrement de comptes. Une unique table nomm√©e Users remplie donc cette
		fonction. Le serveur devra pouvoir y acc√©der en √©criture(inscription) comme
		en lecture(connexion).
			Al√©atoire
		Elle ne comportera que deux champs, userName et password. D√®s lors que
		l'utilisateur d√©sirera cr√©er un compte multijoueur, il renseignera dans
		l'application son userName souhait√© ainsi que son mot de passe. 
		Ce couple sera 	alors envoy√© au serveur qui v√©rifiera dans cette base de
		donn√©es, que le userName(unique) n'est pas d√©j√† utilis√©. Auquel cas un nouveau n-uplet sera
		ins√©r√© et permettra l'authentification de l'utilisateur par la suite. Les mots
		de passe seront bien √©videment crypt√© pour des raisons de s√©curit√©.
			
		
		
		\newpage
		
	