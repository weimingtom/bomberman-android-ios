\subsection{Menus}
	\subsubsection{API et widget}
	\paragraph{Android\\}
		Afin de créer les différents menus de notre application, Android met à la
		disposition des developpeurs une API\footnote{API : Application Programming
		Interface, c'est un ensemble de classes mis à disposition par une
		bibliothèque logicielle.} très bien fournie. Parmis celle-ci le package Widget
		nous a été très utile. Grâce à ce dernier de nombreux objets ont été utilisé
		afin de mettre en oeuvre et rendre pleinement fonctionnel nos menus.
		Parmi les plus utilisés il y a eu bien sûr Button, TextView, CheckBox et
		EditText pour les plus explicites. Les objets comme Spinner, SeekBar et
		Gallery étant respectivement utilisés pour les menus déroulants, les barres de
		progression et les galeries d'images pour la sélection de cartes de jeu.
		
		Concernant leur positionnement, un système de layout est utilisé. Une syntaxe
		de balises xml est là aussi à disposition afin de mettre en forme tout objet
		présent sous forme de vue. Ils sont accessibles via des id uniques par
		fichiers xml, qui permettent de les identifiers. Les listeners présents dans
		les classes java permettent à leur tour d'écouter les évènements utilisateurs
		ou system et réagir en fonction comme l'accès au menu suivant ou le lancement
		d'un partie.
	\paragraph{iOS\\}
		
	\subsubsection{BDD}

		Après avoir effectué divers recherches, il s'est avéré que les mobiles
		utilisent un moteur de base de données relationnelles, accessible par le
		langage SQL. Dans notre cas il s'agit de SQLite 3. Sa particularité est de ne
		pas reproduire le schéma habituel client-serveur mais d'être directement intégrée au programme.
		L'accès à la base de données SQLite se fait par l'ouverture du fichier
		correspondant à celle-ci : chaque base de données est enregistrée dans un fichier qui lui est propre,
		 avec ses déclarations, ses tables, ses index mais aussi ses données.
			
		\paragraph{Android\\}
			
			Pour manipuler aisément les bases de données depuis l'application,
			nous avons crée une classe héritant de \textit{SQLiteOpenHelper}. Cette
			dernière fournit des outils de manipulations. Un attribut y est
			instancié, il s'agit de la base de données elle même, de type
			\textit{SQLiteDatabase}.
			
			Nous y avons crée 3 tables, \textit{PlayerAccount} sauvegardant toutes les
			informations sur les utilisateurs locaux, \textit{System} concervant les
			propriétés du système, et enfin \textit{Map} décrivant les informations
			relatives au cartes de jeu crées par l'utilisateur.
			
			Ainsi de nombreuses	fonctions ont été implémenté dans le but de simplifier les interactions
			avec cette base de données depuis l'application. Il est par exemple possible de créer un nouvel 
			utilisateur local, modifier ses préférences, gérer les configurations systèmes comme la langue ou le volume
			du son, ajoûter de nouvelles maps ou même récupérer toutes les informations
			concernant un utilisateur.\\
			
			Voici un exemple d'insertion d'un nouveau compte local dans la base de
			donnée. Rappelons que les tests d'existance du compte ont été fait depuis
			l'application même. Dans cet exemple vous verrez ainsi que nous commençons
			par récupérer les droits en écritures sur la base de données locale, puis
			nous créons un container qui servira à l'insertion de valeur dans la base. Et
			enfin l'insertion est faite. Nous terminons tout de même en fermant l'accès à
			cette base.
			
			Il s'agit la d'un schéma classique de fonction d'interaction avec notre
			base.
						
			\begin{verbatim}
			/** ajout compte hors ligne **/
				public long newAccount(String nomCompte){
					base = getWritableDatabase();
			
					ContentValues entree = new ContentValues();
					
					entree.put("pseudo", nomCompte);
					long var = base.insert("PlayerAccount", null, entree);
					
					base.close();
					return var;
				}
			\end{verbatim}

			
		\paragraph{iOS}
				
	\subsubsection{Première utilisation}
	\subsubsection{Création utilisateur}
	\subsubsection{Gestion utilisateur}
	\subsubsection{Gestion des préférences système}
	\subsubsection{Création de carte (charger)}
	\subsubsection{Création partie solo (tout)}
	\subsubsection{Création partie multi (officielle)}
			

\subsection{Editeur de carte}

	\hypertarget{Editeur de carte}{}
	\label{Editeur de carte}

	\subsubsection{Rendu}
		\subsubsection{Interface utilisateur}
		\subsubsection{Sauvegarde}


\subsection{Jeu}

	\subsubsection{Moteurs}
	
		Au seins d'un jeu vidéo plusieurs types de moteurs sont mis en place.
		Chacun a un travail bien précis.
		Ici nous en retrouvons trois au total à savoir un pour le rendu graphique, un
		pour s'occuper de la physique et un dernier gerant les actions de
		l'intelligence artificielle.
		Commencons par le moteur de rendu.
	
		\paragraph{Moteur de rendu\\}
		
			Contrairement à celui que nous avons vu dans la section précédente pour
			l'éditeur de carte
			\footnote{
				\hyperlink{Editeur de carte}{Editeur de carte}
				\og voir section \ref{Editeur de carte}, page \pageref{Editeur de carte}.\fg
			}
			le moteur de rendu se doit être beaucoup plus léger car le jeu doit dans son
			ensemble rester le plus fluide afin d'offrir à l'utilisateur une meilleure
			experience vu qu'ici il faut en plus de gérer le rendu, s'occuper du
			physique
			\footnote{
				\hyperlink{Moteur physique}{Moteur physique}
				\og voir section \ref{Moteur physique}, page \pageref{Moteur physique}.\fg
			}.
			, de l'intelligence artificielle
			\footnote{
				\hyperlink{IA}{IA}
				\og voir section \ref{IA}, page \pageref{IA}.\fg
			}.
			et des divers sons
			\footnote{
				\hyperlink{Sons}{Sons}
				\og voir section \ref{Sons}, page \pageref{Sons}.\fg
			}.
			qui seront joués au cours de la partie.		
			
			$\,$	
			
			L'utilisateur ne pourra plus modifier la carte à sa guise et sera
			entièrement dépendant du moteur physique\footnotemark[3] c'est à dire par
			exemple qu'ici un bloc indestructible sera présent tout au long de la
			partie et ne pourra pas être supprimé, il n'est donc plus necessaire de
			savoir quel type de sol se trouve dessous, de plus comme celui-ci ne peut pas
			être détruit et qu'il n'est pas animé son état sera toujours le même et ne
			correspondra qu'à une seule et unique image.
			
			$\,$			
			
			Un autre exemple est celui d'un sol inanimé tel que l'herbe où si il n'y a
			aucun bloc (destructible) au dessus en début de partie il en sera de même à
			la fin donc il ne nous est pas necessaire à chaque rafraichissement de
			regarder si un bloc existe dessus, ce test se fait en début de partie est
			sera valide jusqu'à la fin de celle-ci.
			
			
			Cette remarque s'applique sur tous les objets dits \emph{non animés} dont
			l'état ne changera jamais au cours du jeu et seulement eux.
			
			
			Si l'on avait eu un sol animé représentant de l'eau, il aurait été composé de
			plusieurs images et aurait donc necessité un rafraichissement constant.

			
			Concrètement ce que nous faisons ici à chaque début de partie est de créer
			une image vierge qui aura la taille de la carte affichée sur l'écran dans
			laquelle nous dessinerons tous les objets \emph{non animés}.
			
			$\,$
			
			Pour cela nous allons parcourir les deux matrices définies dans l'éditeur de
			cartes\footnotemark[2] et de regarder s'il existe un bloc, si oui est-ce
			qu'il est destructible ? Si ce bloc est destructible alors il nous est
			obligatoire de savoir ce qui se trouve en dessous on va donc stocker ce bloc
			dans une hashmap dont les cléfs sont les coordonnées de l'objet et dont la
			valeur est l'objet lui même et dessiner le sol sur l'image citée au dessus.
			Si ce bloc est indestructible alors inutile de savoir si un sol existe.
			
			Sinon si il n'existe pas de bloc nous allons regarder si le sol est animé, si
			oui alors on le stok dans la hashmap comme un bloc destructible sinon nous le
			dessinons dans l'image comme un objet inanimé.
			
			$\,$
			
			Voici un exemple concret de la methode décrite au dessus :
			

			\begin{figure}[h]			
				\begin{center}			
					\includegraphics[width=229px, height=142px]{Developpement/Img/map.eps}
					\caption{L'image représentant la totalité des objets non animés}
				\end{center}
			\end{figure}

			\begin{figure}[h]			
				\begin{center}						
					\includegraphics[width=250px, height=250px]{Developpement/Img/hashmap.eps}
					\caption{La hashmap des objets animés}
				\end{center}
			\end{figure}

			$\,$
			
			$\,$

			Les avantages d'avoir utilisé une telle structure est qu'ici au lieu de
			parcourir les 21*13*2 cases des deux matrices à chaque rafraichissement
			(c'est à dire toutes les 50 millisecondes environ) et d'afficher au minimum
			21*13 objets pour le sol et 64 objets pour les bordures si la carte est vide
			donc énormement plus si il existe d'autres objets, nous n'affichons qu'une
			image plus au maximum 197 objets.
			
			\begin{center}
				\begin{tabular}{|c|c|c|} \hline
				  & Editeur de carte & Jeu    \\\hline 
				Meilleur des cas & 337 & 1    \\\hline
				Pire des cas     & 534 & 198  \\\hline		
				\end{tabular}
			\end{center}
			
			Le meilleur des cas ici décrit une carte vide donc composée que de sol non
			animé ansi que des bordures de la carte, ce qui représente dans le nouveau
			moteur de rendu une seule et unique image contrairement à l'ancien où chaque
			objet étant affiché indépendament cela equivaut à 337 objets.
			
			Le pire des cas est une carte remplie au maximum de bloc destructibles,
			obligeant dans les deux cas à connaitre le type de sol se trouvant dessous.
			
			
			Nous voyons très clairement les différences de coûts entre les deux methodes
			de rendu et l'optimisation qu'engendre la deuxième.
			
			De plus ici l'utilisation de la hashmap permet dans un premier temps de
			retrouver directement un objet de par ses coordonnées mais aussi de ne pas
			avoir à parcourir $n$ cases vides comme lors de l'utilisation des matrices
			car au fur et à mesure de la partie il existera de moins en moins d'objets
			donc garder une structure aussi grosse qu'une matrice n'est pas optimal.
		
		\paragraph{Moteur physique}
		
			\hypertarget{Moteur physique}{}
			\label{Moteur physique}
		
			\subparagraph{Structure utilisée}
			\subparagraph{Mouvements (collisions)}
			\subparagraph{Gestion des bombes}
				\begin{itemize}
					\item{Threads}
				\end{itemize}
	
	\subsubsection{IA}
	
		\hypertarget{IA}{}
		\label{IA}
		
		\paragraph{Pathfinding}
			\subparagraph{A*}
			\subparagraph{Aléatoire}
			\paragraph{Prise de décision}
			

	\subsubsection{Sons}
	
		\hypertarget{Sons}{}
		\label{Sons}
	
	\subsubsection{Interface utilisaeur}
		\paragraph{Android}
		\paragraph{iOS}