\subsection{G√©n√©ral}
	Le fait de d√©velopper des applications \gls{ios} et \gls{android}, nous a 
	impos√© le choix du langage.
	En effet pour d√©velopper des applications \gls{iphone}, il faut utiliser 
	le langage \gls{objective-c}.
	Pour les applications \gls{android} c'est le langage \gls{java} qui est 
	utilis√©.
	
	Ces deux langages ont une syntaxe compl√©tement diff√©rente mais sont quand 
	m√™me tr√®s proches car ce sont des langages orient√©s objets.
	Gr√¢ce √† cela nous avons pu mettre au point une mod√©lisation g√©n√©rale de 
	l'application que nous avons ensuite adapt√© √† chaque langage.\\
			
	Nous avons d√©cid√© de d√©velopper en anglais car premi√®rement c'est la langue
	la plus utilis√©e dans le monde de la programmation et deuxi√®mement car la 
	syntaxe des langages est toujours en anglais.
	Cela permettra √† n'importe quel utilisateur de n'importe quelle nationalit√© 
	de comprendre le code de l'application.\\
			
	La documentation des deux applications est √©galement en anglais.
	Cette documentation permettra √† tout utilisateur de comprendre le 
	fonctionnement de celle-ci, que ce soit sur \gls{iphone} ou \gls{android}.
	
	Chacune d'elles est au format \gls{html} et sera donc directement visible 
	gr√¢ce √† un navigateur Web.\\
			
	Pour ce qui est de la mod√©lisation globale du projet, nous avons choisi de 
	d√©velopper les deux applications selon le mod√®le \gls{mvc}.
	Ce dernier est une architecture et une m√©thode de conception qui organise 
	l'\gls{ihm} d'une application logicielle. 
			
	Le mod√®le repr√©sente le comportement de l'application : traitements des
	 donn√©es, interactions avec la base de donn√©es, etc.
	Il d√©crit et contient les donn√©es manipul√©es par l'application, assure 
	la gestion de ces donn√©es et garantit leur int√©grit√©.
			
	La vue correspond √† l'interface avec laquelle l'utilisateur interagit.
	Sa premi√®re t√¢che est de pr√©senter les r√©sultats renvoy√©s par le mod√®le.
	La seconde est de recevoir toutes les actions de l'utilisateur 
	(clic de souris, s√©lection d'une entr√©e, boutons, etc).
			
	Le contr√¥leur prend en charge la gestion des √©v√©nements de synchronisation 
	pour mettre √† jour la vue ou le mod√®le et les synchroniser.
	Il re√ßoit tous les √©v√©nements de l'utilisateur et enclenche les actions 
	√† effectuer.
			
	Gr√¢ce √† cette m√©thode de conception le code est d√©compos√© en trois parties 
	bien distinctes qui permettent la maintenance et l'am√©lioration du projet.
	Cela permet aussi d'am√©liorer chacune des trois parties sans avoir √† 
	modifier les deux autres.
	Par exemple de changer de vue et donc avoir des interfaces graphiques diff√©rentes.
			
\subsection{Menus}

	Au d√©marrage de l'application vous arrivez sur un menu d'accueil. Depuis
	celui-ci vous pourrez acc√©der √† l'aide, √† la liste des comptes locaux ou √† la
	cr√©ation d'un nouveau compte local.
	
	Ils se divisent en quatre grandes sections.
		
	Premi√®rement la section de cr√©ation de parties locales dans laquelle l'utilisateur
	pourra choisir parmi une liste de cartes celle sur laquelle il d√©sire jouer.
	Le r√©glage de la difficult√© des \glspl{bot}, leur nombre et le temps de jeu.
		
	Dans la m√™me cat√©gorie se trouve la section des parties multijoueurs. En
	acc√©dant √† celle-ci vous allez pouvoir vous connecter √† votre compte
	multijoueur ou le cr√©er s'il n'est pas d√©j√† fait. Vous acc√®derez ensuite √† la liste
	des parties multijoueurs, que vous pourrez rejoindre ou choisir de cr√©er la
	votre. Dans le menu cr√©ation le principe est proche des parties locales.
		
	Suite √† ces deux sections vient ensuite l'√©diteur de cartes.
	C'est depuis ce menu que vous cr√©erez une nouvelle map de jeu local ou 
	√©diterez l'une d'entre elles.
		
	Enfin vient le menu des options o√π vous pourrez g√©rer vos
	pr√©f√©rences syt√®mes telles que le volume ou la langue de
	l'application(anglais, fran√ßais).
	Une sous-section de gestionnaire de profil est aussi pr√©sente.
	Une √©dition de vos comptes locaux, multijoueurs ou m√™me
	vos param√®tres de jeu comme la position du menu, sont modifiables depuis ce 
	menu.
	
	\begin{figure}
		\label{activit√©}
		\includegraphics[width=23cm, angle=90]{Analyse/Img/diag_activity.eps}
		\caption{Diagramme d'activit√©}
	\end{figure}

	\paragraph{Base de donn√©es\\}
			
		Une base de donn√©es locale a elle aussi √©t√© con√ßue. Cette derni√®re a pour
		but de stocker plusieurs types de donn√©es.
				
		En effet d√®s lors qu'un compte local est cr√©√© sur le t√©l√©phone dans la
		table PlayerAccount, il est possible de conserver ses pr√©f√©rences tels 
		que la couleur du joueur, le pseudonyme ou m√™me ses param√®tres de connexion multijoueur.
				
		L'application est par ailleurs en mesure de conserver
		les valeurs sonores, la langue et m√™me le dernier utilisateur de
		l'application gr√¢ce √† un son identifiant qui est cl√© √©trang√®re dans la table System(attribut lastUser).
				
		De plus l'application sera d√©livr√©e avec quelques cartes officielles, mais
		l'utilisateur aura libre droit de cr√©er ses propres cartes de jeu via un
		√©diteur. Elles seront alors stock√©es dans la table Map avec toujours une
		cl√© √©trang√®re vers l'identifiant de son cr√©ateur. \\
		
		\newpage
				
		\begin{figure}
			\includegraphics[width=11cm]{./Analyse/Img/menu_bdd.eps}
			\caption{Diagramme de classe Base de donn√©es}
		\end{figure}	
	
\subsection{Editeur de carte}	

	L'√©diteur de carte est une fonctionnalit√© qui va permettre √† un utilisateur
	 de cr√©er facilement ses propres cartes pour ensuite y jouer dessus contre 
	 l'intelligence artificielle.
	 
	Apr√®s avoir r√©fl√©chi sur toutes les fonctionnalit√©s que l'√©diteur de carte 
	devait remplir, nous avons retenu celles-ci : permettre √† l'utilisateur 
	d'en cr√©er une nouvelle, mais aussi de pouvoir charger une ancienne carte 
	pr√©c√®demment cr√©√©e.
	
	Il peut modifier le sol de la carte, ajouter ou supprimer des blocs de 
	la carte et enfin placer les diff√©rents points de d√©part des joueurs sur 
	la carte.
		
	Pour r√©aliser cette partie de l'application, nous avons aussi utilis√© le 
	mod√®le de conception \gls{mvc}.

	\subsubsection*{Mod√®le}
		La partie mod√®le va contenir toutes les donn√©es de l'√©diteur de carte. Les cartes sont les principales donn√©es qu'il va devoir manipuler. Pour cela, nous avons d√©cid√© de la r√©pr√©senter sous la forme de deux matrices, la premi√®re repr√©sentant les objets du premier niveau (le sol) et la deuxi√®me la matrice du second niveau (les blocs).
			
			
	\subsubsection*{Vue}
		Ensuite, la vue repr√©sentera l'interface graphique de notre √©diteur de carte. La principale difficult√© pour r√©aliser l'interface graphique √©tait de devoir rentrer toutes les informations n√©cessaires pour l'√©diteur de carte dans un √©cran de type \gls{smartphone}. Apr√®s plusieurs prototypes d'interface, nous avons d√©cid√© de s√©parer l'interface en trois parties. Tout d'abord la plus grande partie, l'affichage de la carte, qui comme √©tant la principale information √† afficher, nous avons essay√© de maximiser sa taille. Ensuite un menu √† droite permettant au joueur de changer d'outil. Et la derni√®re partie affiche les diff√©rents √©l√©ments permettant de contrôler l'√©diteur de carte. L'utilisateur aura juste √† choisir l'outil qu'il veut placer sur la carte gr√¢ce au menu de droite et ensuite il lui suffira d'appuyer sur la carte pour placer un bloc dessus.
		
		\begin{center}
			\includegraphics[width=11cm]{./Analyse/Img/14-Editeur_de_niveau.eps}
		\end{center} 
			
	\subsubsection*{Contr√¥leur}
		
		Pour finir, le contr√¥leur a pour but de faire la liaison entre les 
		donn√©es du mod√®le et de la vue.
		Chaque vue poss√®de son contr√¥leur.
		Il y a un contr√¥leur gobal poss√©dant les contr√¥leurs de chaque vue.
			

	\subsection{jeu}
	
	Comme vue dans le cahier des charges, l'application est divis√©e en 
	trois grandes parties: le mod√®le, la vue et le contr√¥lleur.
	
	\begin{center}
		\includegraphics[scale=0.41, angle=90]{./Analyse/Img/BomberblocDiagramme.eps}
	\end{center}
	
	\subsubsection{Mod√®le}
	
		Le mod√®le constitue la \textit{base} de notre projet.
		C'est sur celui-ci que nous avons construit le reste de l'application.
		Ce dernier se d√©compose en trois sous-partie: la partie hierarchie des objets, la partie moteur puis la partie √©diteur de carte.\\
		
	\paragraph{Hierarchie des objets \\}
	
		Pour concevoir la hierarchie des objets, il a fallu tout d'abord 
		dinstinguer la totalit√© des objets qui seraient disponibles dans 
		le jeu ainsi que leurs diff√©rences et leur point communs.
		
		Pour cela nous avons donc distingu√© quatre grands types d'objets:
		\begin{itemize}
		  \item Les destructibles
		  \item Les indestructibles
		  \item Les anim√©s
		  \item Les inanim√©s
		\end{itemize}
		
		En sachant que les objets pouvaient √™tre destructibles-anim√©s, 
		destructible-inanim√©s, indestructible-anim√©s ou indestructible-inanim√©s.
		Nous avons choisi que tout objet serait consid√©r√© comme un objet anim√© 
		pour √©viter des soucis de mod√©lisation.
		Ainsi les objets poss√®deront tous une sequence d'animation d'images qui
		 sera dessin√©e √† l'√©cran.
		Cette derni√®re sera tournera en boucle dans le cas d'une animation 
		qui se r√©p√©t√© et qui comporte plusieurs images, sinon si elle poss√®de 
		simplement qu'une seule image.
		Nous avons ensuite dinstingu√© une multitude de point communs entre 
		les diff√©rents objets dont voici le nom des attributs et leur utilit√© : 
	
	\begin{description}
		\item [\textit{position}]{indique la position en pixel de l'objet sur l'√©cran}
		\item [\textit{nom}]{indique le nom de l'objet}
		\item [\textit{hit}]{est √† 1 si l'objet ne peut √™tre travers√© par un joueur}
		\item [\textit{level}]{est √† 0 si l'objet est sur le sol, 1 sinon}
		\item [\textit{fireWall}]{est √† 1 si l'objet ne laisse pas passer les flammes des explosions (0,sinon)}
		\item [\textit{damages}]{indique si l'objet peut infliger des dommages}
		\item [\textit{idle}]{est une image qui repr√©sente l'objet en son √©tat dit de repos}
		\item [\textit{animates}]{est une table de hachage contenant l'ensemble des images composant la sequence d'animation de l'objet (vide si inanim√©s)}
		\item [\textit{destroy}]{est une table de hachage contenant l'ensemble des images composant la sequence d'animation de destruction de l'objet (vide si indestructible)}
		\item [\textit{currentFrame}]{permet de connaitre le num√©ro de l'image courante de la sequence d'animation en cours d'affichage}
	\end{description}

		Nous avons donc d√©cid√© de concevoir une classe "Objects" pour mod√©liser
		 toutes ces propri√©t√©s que les objets ont en commun.
		 
		Cette classe sera abstraite car tout objet est destructible ou 
		indestructible et cela sera d√©cris dans des classes plus sp√©cialis√©s.
	
	 	Ensuite nous avons pens√© √† cr√©er deux autres classes: "Destructible" 
	 	et "Undestructible" pour les objets destructible et indestructible.
	 	Ces deux classes h√©ritent de "Objects" car elles sont des objets.
	 	
	 	Ce qui diff√©rencie ces deux classes est le champ \textit{life} qui 
	 	permet de savoir combien de fois l'objet doit etre touch√© par une 
	 	bombe avant d'√™tre detruit.
	
		Nous avons ensuite dinstingu√© deux autres types d"objets encore plus sp√©cifiques :
		Les joueurs et les bombes.
		Ces derniers sont des objets destructibles puisqu'ils ne durent pas 
		toute la partie selon le mode de jeu.
	
		Les bombes poss√®dent deux nouveaux attributs qui les diff√©rentient 
		des autres objets :
		
			\begin{description}
				\item [\textit{type}]{permet de connaitre le type de bombe}
				\item [\textit{owner}]{Joueur qui ayant pos√© la bombe}
			\end{description}
			
		Quant √† la classe joueur celle-ci poss√®de encore d'autres attributs :
		
		\begin{description}
			\item [\textit{color}]{Affiche √† l'√©cran le joueur avec sa bonne couleur}
			\item [\textit{bombsTypes}]{Type de bombe qu'il peut poser}
			\item [\textit{powerExplosion}]{Port√© d'explosion de ses bombes}
			\item [\textit{timeExplosion}]{Temps d'explosion de ses bombes}
			\item [\textit{speed}]{Vitesse du joueur}
			\item [\textit{shield}]{Valeur du bouclier}
			\item [\textit{bombNumbers}]{Nombre maximum de bombes que le joueur peut poser}
			\item [\textit{isTouched}]{Permet de savoir si le joueur viens d'√™tre touch√©}
			\item [\textit{isKilled}]{Permet de savoir si le joueur est mort}
			\item [\textit{isInvincible}]{Permet de savoir si le joueur est invincible}
		\end{description}
	
		Cette hierarchie de classe nous permettra donc de mod√©liser l'ensemble 
		des objets que le jeu pourra afficher.
	
	
	\paragraph{Moteur\\}
	
		Pour ce qui est du moteur.
		Celui-ci est repr√©sent√© par une classe "Engine".
		Cette classe va contenir l'ensemble des m√©thodes qui vont permettrent 
		d'√©tablir les collisions.
		C'est aussi cette classe qui s'occuppe de mettre √† jour les bombes 
		ainsi que l'\gls{ia} du jeu.
		
		Une instance d'un moteur est associ√©e √† une partie dont le nom de classe est "Game".
		Cette classe "Game" est abstraite et repr√©sente une partie avec toutes les options qu'elle contient.
		
		C'est √† dire qu'elle poss√®de des attributs permettant de d√©crire le type de partie,
		un tableau avec chaque joueur de la partie, ainsi que le carte du jeu.
		La classe poss√®de toutes les m√©thodes d'initialisation, de mise √† jour,
		 de dessins et de fin de la partie.
		
		Enfin pour diff√©rencier les diff√©rents types de parties nous avons utilis√©
		 le \gls{pattern} d√©corateur.
		 Ainsi il y aura deux grands types de parties: les parties solitaires 
		 et les parties multijoueurs.
		 Puis ces parties sont d√©cor√©s par le type de partie: \gls{survivor} ou \gls{death_match}.
	
		Ensuite pour ce qui est des cartes, une classe abstraite nomm√© "Map" 
		contient le nom et la taille de la carte ainsi qu'un tableau contenant 
		la position initial de chaque joueur sur la carte.
		
		Puis une classe "GameMap" qui h√©rite de map permet de dessiner 
		la carte a l'√©cran lors du jeu.
		Elle se compose d'une image repr√©sentant le sol puis d'un tableau 
		d'objets anim√©s qui permet de repr√©senter l'ensemble du reste des objets.
		
		Ensuite nous utilisons un autre type de carte qui va permettre de 
		faciliter les collisions, que ce soit pour un joueur humain ou pour 
		une intelligence artificielle.
		Cette classe est appel√© "CollisionMap" et contient une matrice d'objets
		"CollisionCase" ainsi qu'un tableau qui contient l'ensemble des bombes 
		pos√©es sur la carte.
		Les "CollisionCase" sont compos√©es de deux tableaux.
		Chaque valeur d'un des tableaux est associ√©e √† une valeur de l'autre tableau.
		Un tableau \textit{types} contient les diff√©rents types de danger ou d'objets 
		qui existent sur cette case ainsi qu'un tableau \textit{counters} permettant 
		en fonction de chaque type de compter le nombre de fois que ce danger ou objet 
		est pr√©sent sur cette case.
		Par exemple on peut tr√®s bien avoir une case qui est dans le champ d'explosion
		de quatres bombes et qui contient un bloc de type destructible.
		
		Ainsi le tableau \textit{type} contiendra deux champs, un pour le 
		type zone dangereuse et un autre pour le type bloc destructible puis 
		le tableau \textit{counters} contiendra donc dans sa case associ√©e √† 
		la case zone dangereuse une valeur √©gale √† quatre et et une valeur de
		un pour l'autre.
		
	
	\subsubsection{Vue}
	
		L'interface graphique du jeu est d√©compos√©e en trois parties.
		Une partie qui repr√©sente le menu d'information de la partie, 
		une autre qui r√©pr√©sente le menu des actions possibles du joueurs 
		et une derni√®re qui repr√©sente la partie en cours.
		
		Le menu d'information se situe en haut de l'√©cran.
		Il permet d'afficher le score des joueurs, le temps lors d'une partie 
		death match ainsi que les bonus du joueurs (le nombre de bombes qu'il 
		peut poser, la port√©e de l'explosion des bombes, la vitesse du joueur 
		et les bonus de vie) et de mettre le jeu en pause.
		
		Le menu d'action se situe √† droite de l'√©cran.
		Il permet √† l'utilisateur de poser les bombes gr√¢ce √† un bouton 
		et aussi de changer de type de bombes gr√¢ce √† une liste d√©roulante.
	
		Quant √† la partie, elle est affich√©e au centre de l'√©cran et prend le 
		maximum de place possible pour que le jeu soit le plus visible.
		Elle permet d'afficher la carte ainsi que les joueurs et les bombes.
		Mais elle sert aussi √† √©couter les mouvements du doigt de l'utilisateur
		pour modifier les coordonn√©es du joueur dans le mod√®le pour pouvoir 
		ensuite rafraichir l'√©cran et voir le joueur se deplacer.	
	
	
	\subsubsection{Controlleur}
	
		Le controlleur va permettre de faire la liaison entre la vue et le mod√®le.
		La majorit√© de ces m√©thodes sont appel√©es lorsque l'utilisateur interagit avec la vue.
		Ces m√©thodes vont par la suite modifier le mod√®le qui va permettre de mettre √† jour la vue.
		Le controlleur est divis√© en quatre sous-controlleurs.
		Chacun des trois premiers est respectivement associ√© √† l'une des trois vues cit√© ci-dessus.
		Puis le quatri√®me est plus g√©n√©ral, il permet de faire la liaison entre les trois autres controlleurs.
		Car en effet chacune des actions effectu√©es sur l'une des vues peut modifier l'une des deux autres.
	
	\subsubsection{GamePlay}
	
		Nous avons choisi d'√©tablir un gameplay immersif.
		Notre gameplay est divis√© en trois parties: les d√©placements, la pose des bombes et la gestion des diff√©rents types de bombes.
		
		Pour ce qui est des d√©placements du joueurs, nous avons d√©cid√© que 
		l'utilisateur utiliserait toute la surface de l'√©cran pour se d√©placer.
		Ainsi si il veut se d√©placer vers la droite, il fait glisser sont doigt 
		de la gauche vers la droite, puis tant qu'il restera appuy√© sur l'√©cran,
		le joueur continura de se d√©placer.
		Cette mani√®re de se d√©placer est pr√©cise et tr√®s intuitive contrairement
		√† l'utilisation d'un joystick virtuel ou de l'acc√©l√©rom√®tre.
		
		Pour la pause des bombes un simple boutton est mit en √©vidence en bas √†
		 droite de l'√©cran.
		 Celui-ci est assez gros pour que l'utilisateur n'est pas √† appuyer sur
		 une zone trop pr√©cise en cas de manipulation rapide.
		
		Puis pour le choix des diff√©rentes bombes, une simple liste d√©roulante 
		est mise en √©vidence √† droite du jeu.\\
		
		\subsubsection{Tile Mapping}

			La gestion des images a √©t√© une partie tr√®s importante de l'analyse
			car le d√©veloppement mobile impose plusieurs contraintes, notamment 
			la gestion de la m√©moire et la vitesse d'affichage.
			
			Nous nous sommes donc inspir√©s des premiers jeux consoles comme 
			Super Mario Bros ou Zelda qui ont √©t√© d√©velopp√©s sur les premi√®res 
			consoles comme la \gls{nes} ou la \gls{game_boy}.
			Nous avons donc con√ßu le moteur du jeu selon le principe du \gls{tile_mapping} 
			pour minimiser l'utilisation des ressources des t√©l√©phones.
		
			Le principe du Tile Mapping est d'utiliser des petites images que nous appelerons \textit{tiles}.
			Ces tiles sont toutes contenues dans une image.
			Ensuite une matrice de nombre entier est utilis√© pour repr√©senter l'environnement du jeu.
			Chaque nombre entier repr√©sente un tile.
			Puis gr√¢ce √† cette association, la carte sera dessin√© √† l'√©cran selon la matrice.
			Voici un exemple :
		
			\includegraphics[width=15cm]{./Analyse/Img/tileMapping.eps}
		
			Pour pouvoir animer certains de ces objets nous avons utilis√© des sprites.
			Les sprites contrairement aux tile sont un ensemble d'images repr√©sentant
			une animation.
		
			Nous avons donc repris ce principe et nous l'avons am√©lior√©.
			En effet gr√¢ce √† la programmation objet, les entiers sont r√©pr√©sent√© directement par des objets
			contenant les tiles/sprites qui les repr√©sentent.
			
			Ainsi, nous stockons dans une matrice tous les objets inanim√©s
			(les objets dont le tile restera le meme tout le long de la partie)
			et nous parcourons cette matrice pour dessiner chaque objet √† sa 
			position pour obtenir une nouvelle image au format png.
			A chaque rafraichissement de l'√©cran, seule la nouvelle image est dessin√©e 
			et non pas chaque tile.
			Cette m√©thode permet d'√©viter un parcours intempestif de la matrice.
			
			Ensuite pour le reste des objets dit anim√©s (rep√©sent√©s par des sprites)
			nous avons d√©cid√© de les stocker dans une table de hachage dont la 
			cl√© est la position de l'objet (pour y acc√©der plus rapidement).
			Lors du rafraichissement de l'√©cran on parcourra entierement la 
			table de hachage et l'on dessinera l'image courante de la sequence 
			d'animation de chaque objet.
		
		\subsubsection{La gestion des images et du son}
		
			Chaque image et chaque son dont est compos√© le jeu sont charg√©s au lancement de l'application.
 			
 			Afin de pouvoir ajouter facilement un objet et le modifier sans avoir √† toucher au code
 			source, nous avons d√©cid√© d'opter pour les stocker sur des fichiers au format \gls{xml}
 			Les fichiers \gls{xml} ressemblent tous plus au moins a ce genre d'arborescence: 
		
		\includegraphics[width=15cm]{./Analyse/Img/exampleXmlBomberklob.eps}
		
			Chaque fichier \gls{xml} commence par une balise racine permettant 
			de lister les objets qu'elle contient (\textit{<objects>}).
			Ensuite chaque objet est d√©cris par une balise  qui contient le type,
			le nom de l'objet ainsi que l'ensemble de ses propri√©t√©s.
			
			La propri√©t√© \textit{hit} est √† 1 si l'objet n'est pas traversable par un joueur (0, sinon), 
			le champ \textit{level} est √† 1 si l'objet se trouve au premier niveau de la carte (0,sinon), 
			le champ \textit{fireWall} est √† 1 si l'objet ne laisse pas passer les flammes des explosions, 
			le champ \textit{life} indique le nombre de fois que l'objet doit etre touch√©
			et enfin le champ \textit{damages} indique si l'objet peut infliger des domages.
			
			Par exemple \textit{<destructible name="herb" hit="1" level="1" fireWall="1" life="1" damages="0">} 
			d√©cris un objet de type \textit{destructible}, qui n'est pas traversable, se trouvant au niveau
			1 sur la carte, ne laissant pas passer les flammes des bombes, possedant une vie, 
			n'infligeant pas de dommage et dont le nom est \textit{herb}.
			
			Ensuite chaque objet poss√®de au plus trois balises animations (sauf pour les joueurs).
			Tout objet poss√®de au moins la premiere balise: 
			<animation name="idle" canLoop="false" sound="sound\_path"> 
			qui est celle dont le nom est \textit{idle}.
			
			Elle repr√©sente l'image standard de l'objet.
			Par exemple pour un objet bombe, ce sera l'image qui sera affich√©e dans la liste des bombes 
			pour pouvoir selectionner ses bombes.
			Le champs \textit{canLoop} permet de savoir si l'animation doit √™tre r√©p√©t√©e en boucle 
			et le champ \textit{sound} contient le chemin d'acc√®s au fichier de son de l'animation 
			si elle en possede un.
			
			Il y a ensuite la balise mais dont le nom est \textit{animate}, celle-ci contiendra *
			toutes les sequences d'images d'un objet qui est anim√©s.
			La derni√®re est celle dont le nom est \textit{destroy} et qui contiendra 
			l'ensemble des images composant la sequences d'animation de destruction de l'objet.
			Enfin chaque balise de type animation contient des balises de type \textit{framerect}.
			Ces balises permettent de donner la position de chaque image de la s√©quence d'animation
			dans la bitmap globale ainsi que le delai de rafraichissement entre chaque image.
			Par exemple \textit{<framerect top="60" left="30" bottom="90" right="60" delayNextFrame="1" />}
			repr√©sente une image dont le bord du haut est situ√© √† 30pixels, le bord du bas √† 90pixels, 
			le bord de gauche √† 30pixels et le bord de droite √† 60pixels en partant du coin en haut √† 
			gauche de l'image globale.
			Puis pour le champ \textit{delayNextFrame} celui-ci informe que l'image suivante sera d√©clench√©e 
			apres un delay de 1s.\\
		
			Gr√¢ce √† cette mod√©lisation, l'application va parcourir au d√©marrage l'ensemble des fichiers 
			XML et va cr√©er une table de hachage pour chaque ensemble d'objet du fichier.
			Lors de ce parcours, l'application va instancier chaque objet avec toutes propri√©t√©s 
			que lui indique le document XML, ainsi que ses sequences d'animations.
			Ensuite lorsqu'un objet devra √™tre utilis√© dans le jeu, il suffira d'utiliser 
			une copie de l'objet d√©ja charg√© en m√©moire pour √©viter d'avoir √† reparcourir le fichier.
			
			
	\subsubsection{Intelligence artificielle}
	
		Comme nous avons vu dans le cahier des charges, nous avons mis en 
		place une intelligence artificielle permettant √† un joueur de jouer 
		en solotaire.
	
		Tout d'abord, nous avons d√ª r√©fl√©chir √† toutes les actions que les 
		\glspl{bot} pourraient effectuer, lors d'une partie.
		
		L'intelligence artificielle dans notre jeu utilise des algorithmes de \gls{recherche_op}.
		
		Pour une meilleure exp√©rience de jeu, nous avons s√©par√© l'intelligence artificielle en trois niveaux.
		
		$\,$
		
		\begin{itemize}
		  \item Facile
		  \item Moyenne
		  \item Difficile
		\end{itemize}
		
		$\,$
		
		Nous avons utilis√© deux types d'algorithmes de \gls{recherche_op} bas√©s sur le \gls{pathfinding}.
		
		\paragraph{Pathfinding}
		
			Le premier algorithme bas√© sur le parcours en largeur est utilis√© quel que soit
			le niveau de l'intelligence artificelle choisi contrairement au second qui n'est utilis√©
			que pour la difficult√© moyenne et difficile.
		
		\subparagraph{Parcours en largeur\\}
		
			L'algorithme du parcours en largeur dans notre cas, consiste √† partir d'un sommet S,
			lister d'abord tous les voisins de S pour ensuite les explorer un par un.
			Ici nous allons donc regarder toutes les cases autour de nous, puis regarder
			tous leurs voisins et cela ainsi de suite jusqu'√† trouver un point
			correspondant √† nos attentes.
			
			Le contexte est le suivant, un \gls{bot} d√©couvre qu'il est sur la trajectoire
			d'explosion d'une bombe est va donc fuir vers la case s√ªr la plus proche or
			il n'a aucune id√©e d'o√π elle se trouve.
			
			L'image suivante repr√©sentera la situation initiale :
			
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/largeur_0.eps}
			\end{center}
			
			Comme dit pr√©c√©demment il n'y a que les murs ou les bombes que l'on ne peut
			pas traverser sinon tous les autres objets ou joueurs sont traversables.
			Nous considerons que les bombes ont ici un champs d'explosion en nombre de
			cases de 4.			
			
			Repr√©sentons la carte ci-dessus d'une fa√ßon plus parlante en remplacant les
			divers objets (mis √† part le joueur) par des couleurs leur correspondant, √†
			savoir :
			
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/largeur_1.eps}
			\end{center}
			
			Mettons nous √† present √† la place du \gls{bot}.
			
			Nous allons donner un poids aux cases que nous allons parcourir
			correspondant √† la distance par rapport √† la case initiale, ainsi qu'une
			direction qui correspondra √† la direction initiale que le \gls{bot} devra empruter
			pour utiliser ce chemin, c'est √† dire par exemple que tout chemin d√©couvert
			dont l'origine est une case √† droite de la notre aura comme direction droite.
			
			A partir d'une case donn√©e, nous ne regarderons que les voisines ayant un poids de 0,
			car si leur poids est diff√©rent cela voudra dire que nous les avons d√©j√† vu pr√©c√©demment et bien √©videmment,
			nous ignorerons les murs ainsi que les bombes.
			
			Nous avons chang√© la valeur des cases intraversables pour ne pas confondre avec le poids des cases visit√©es.			
			
			Appliquons l'algorithme de parcours en largeur aux cases voisines de la notre.
			
			
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/largeur_2.eps}
			\end{center}
			
			
			Toutes les cases d√©couvertes √©tant consid√©r√©es comme dangereuses (voir le sch√©ma pr√©c√©dent), nous continuons √† appliquer l'\gls{algorithme} jusqu'√† arriver √† notre but.
			
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/largeur_3.eps}
				
				$\,$
				
				\includegraphics[width=8cm]{./Analyse/Img/largeur_4.eps}
			\end{center}
			
			Ici nous avons d√©couvert une case non dangeureuse en $(13,6)$.
			
			Nous r√©cup√©rons donc la direction enregistr√©e dans cette case et bougeons en fonction de celle-ci.
			
			Si plusieurs cases avaient √©t√© d√©couvertes, le choix aurait √©t√© arbitraire car elles auraient toutes √©t√© √† la m√™me distance.
			
			$\,$
			
		\subparagraph{A*\\}
		
			L'action la plus importante que l'intelligence artificielle doit savoir faire c'est de pouvoir se d√©placer librement sur la carte en fonction des diff√©rents objets pr√©sents sur la carte et des actions effectu√©es par les autres joueurs.
		
			L'algorithme de recherche A* a pour but de rechercher un chemin
			dans un graphe entre un n≈ìud initial et un n≈ìud final tous deux pr√©alablement
			d√©finis. A* permet de trouver l'un des meilleurs (mais pas forc√©ment le
			meilleur) chemins existant entre un point A et un point B (il retourne le premier chemin trouv√©).
			
			La force de cet algorithme est le temps de calcul et l'exactitude des r√©sultats, contrairement √† Dijkstra qui lui fournit toujours le meilleur r√©sultat (le plus court chemin entre deux points) mais dans un temps d'ex√©cution beaucoup plus long que l'algorithme de A*.
			
			Sachant qu'il peut y avoir jusqu'√† trois \glspl{bot} et que l'intelligence artificielle doit r√©guli√®rement recalculer son chemin en fonction des actions effectu√©es par les autres joueurs, nous avons donc choisi l'algorithme de A*.
		
			Maintenant que l'on sait quel algorithme utiliser pour rechercher un chemin dans un graphe, nous allons voir en d√©tail comment marche l'algorithme de A*.
		
			Pour comprendre comment l'algorithme marche, nous allons nous aider d'un
			dessin repr√©sentent une carte avec un point A (d√©part) affich√© en vert, un
			point B (arriv√©e) en rouge, et o√π les cases en bleu repr√©sentent les murs.
		
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille.eps}
			\end{center}
		
			La premier chose que l'on peut observer, c'est que la carte est divis√©e en
			cases. Chaque case de la matrice repr√©sente un node qui peut √™tre soit
			traversable, soit non traversable. Dans l'application, il n'y a que les murs
			ou les bombes que l'on ne peut pas traverser sinon tous les autres objets
			ou joueurs sont traversables. Le but de l'algorithme est donc de
			trouver un chemin entre A et B en √©vitant les murs.
			
		
			Durant le d√©roulement de l'algorithme, nous avons utilis√© deux listes qui contiennent des cases de la carte.
			Il y a une liste dite \og listeOuverte \fg \, et l'autre \og listeFerm√©e \fg.
			La listeOuvrete contient une liste de cases qui pourraient √©ventuellement faire partie du chemin, mais pas forc√©ment, pour le moment elle sera vide.
			Plus pr√©cis√©ment c'est une liste de cases que nous devons v√©rifier.
			Ensuite, au niveau de la listeFerm√©e, elle contient toutes les cases que nous
			aurons d√©j√† v√©rifi√©es, au d√©but de l'excution, elle contient que le point de d√©part (B3).
			
		
			Commencons les explications du d√©roulement de l'algorithme.
			Tout d'abord, il faut savoir qu'un joueur peut se d√©placer dans toutes les
			directions, donc nous allons ajouter toutes les cases adjacentes √† la
			listeOuvert qui sont traversables, il y en a huit (A2, B2, C2, A3, C3, A4, B4, C4).
			
			
			Ce qui nous donne :
		
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille2.eps}
			\end{center}
		
			Les carr√©s avec un contour rouge sont les carr√©s pr√©sents dans la
			listeOuverte et les carr√©s qui ont une couleur un peu plus fonc√©e que les
			autres sont ceux qui se trouvent dans la listeFerm√©e.
		
			Maintenant pour choisir la case par laquelle on doit passer, nous devons rajouter trois donn√©es \og F \fg , \og G \fg \, et \og H \fg:
			\begin{description}
				\item[G : ]{c'est le co√ªt de mouvement pour aller de la case A √† une case donn√©e sur la grille, en suivant le chemin g√©n√©r√© jusqu'√† cette derni√®re.}
				\item[H :]{c'est l'heuristique, c'est √† dire le co√ªt estim√© pour all√© du point courant √† l'arriv√©. Comme nous ne connaissons pas vraiment la distance qu'il nous reste √† parcourir, car toutes sortes d'obstacle peuvent se trouver sur notre chemin (objet non traversable). Donc nous allons devoir l'approximer gr√¢ce √† une fonction, pour la calculer nous avons choisi d'utiliser l'heuristique de Manhattan, qui consiste √† compter le nombre de bloc (√† vol d'oiseau et sans prendre les diagonales) qui lui reste √† parcourir.}
				\item[F :]{c'est G + H}
			\end{description} 
		
			Chaque case de la listeOuverte ou de la listeFerm√©e vont devoir poss√®der toutes ces donn√©es, plus les coordonn√©es de leur p√®re, c'est √† dire les coordonn√©es de la case qui vient de les ajouter dans la la listeOuverte. Pour calculer G, nous allons assigner un co√ªt de 10 pour chaque d√©placement horizontal ou vertical, et un co√ªt de 14 pour un mouvement en diagonale. Nous utilisons ces donn√©es car la distance n√©cessaire pour se d√©placer est la racine carr√©e de 2, ou approximativement 1.41 fois le co√ªt d'un d√©placement vertical ou horizontal. Nous utiliserons donc 10 et 14 pour des raisons de simplification. Par cons√©quent, nous allons multiplier par 10 le co√ªt H pour qu'il soit coh√©rent par rapport √† G.
	
			Donc maintenant, nous devons avoir cette matrice :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille3.eps}
			\end{center}
		
			Apr√®s avoir ajout√© toutes les cases adjacentes √† la case courant, il suffit de prendre la case qui a le plus petit co√ªt F et ensuite de la rajouter dans la listeFerm√©e et de la supprimer de la listeOuverte. Nous obtenons donc :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille4.eps}
			\end{center}
		
			Ensuite on regarde toutes les cases adjacentes √† la derni√®re case ajout√©e dans la listeFerm√©e. Si elles se trouvent d√©j√† dans la listeOuverte, on v√©rifit que leurs co√ªt soient inf√©rieur au co√ªt de la case correspondante d√©j√† dans la listeOuverte, si oui alors on la remplace sinon on ne fait rien.
		
			Pour finir on r√©p√®te cette op√©ration jusqu'on arrive √† la case d'arriv√©e, nous obtenons √ßa :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille5.eps}
			\end{center}
		
			Pour finir, il nous suffit juste de r√©cup√©rer la case d'arriv√©e et de regarder son p√®re, puis de rep√©ter cette op√©ration avec la case obtenu jusqu'√† arriver √† la case de d√©pard. Gr√¢ce √† √ßa nous obtenons cette derni√®re √©tape de l'algorithme :
			\begin{center}
				\includegraphics[width=8cm]{./Analyse/Img/Grille6.eps}
			\end{center}
		
			Comme nous pouvons levoir sur le sch√©ma precedent, le chemin qu'a trouv√© l'algorithme de A* est le suivant : $ B3 \rightarrow C4 \rightarrow C5 \rightarrow D5 \rightarrow E5 \rightarrow F4 \rightarrow F3 $. L'algorithme aurait pu d'autre chemin √©quivalent √† celui-ci mais le principe de cette algorithme c'est de renvoyer le permier chemin qu'il trouve.


\subsection{R√©seau}
		
	\paragraph{Serveur\\}
			
		Il a √©t√© fix√© dans le cahier des charges que notre serveur devrait pouvoir
		effectuer plusieurs t√¢ches particuli√®res s√©par√©es. Nous avons donc d√©cid√© de
		les compartimenter en classes.
		
		Notre serveur est cr√©e sur une base de servlet. Ce f√ªt ici
		aussi un point nouveau pour nous, r√©iterant les phases d'analyse, de
		d√©couverte, de test et de mise en place. Le fonctionnement est bas√© sur les
		√©changes de requ√™tes type HTTP, o√π √† chaque demande correspond une r√©ponse. 
		
		Une servlet est une classe Java qui permet de cr√©er dynamiquement des donn√©es
		au sein d'un serveur HTTP. Une servlet s'ex√©cute dynamiquement sur le serveur
		web et permet l'extension des fonctions de ce dernier, typiquement : acc√®s √†
		des bases de donn√©es.
			
		Les six √©l√©ments situ√©s sur la partie haute du sch√©ma
		ci-dessous(respectivement ServletInscription, ServletConnection,
		ServletGamesList, ServletCreateGame, ServletConnectionGame et
		ServletManageGame), repr√©sentent les diff√©rentes t√¢ches qu'un utilisateur
		puisse demander au serveur. Elles sont reli√©es √† une classe nomm√©e
		ContextListener, qui leur permettra d'acc√©der aux m√™mes donn√©es sans qu'il y
		ait de conflit. La partie basse repr√©sente les objets qui seront utilis√©s 
		pour les parties en multijoueur. 
		Bien √©videmment ces objets sont tr√®s proches de ceux utilis√©s dans les parties
		locales(Sch√©ma 3.3).
		
		
		Comme il a √©t√© dit pr√©c√©dement, notre serveur est accessible via des requ√™tes
		HTTP contactant des servlets. Ces servlets sont stock√©es dans un serveur
		d'application nomm√© Apache Tomcat. Il s'agit d'un conteneur libre de
		servlets Java 2 Enterprise Edition, mais il fait aussi office de serveur
		Web.\\
		Un sc√©nario probable serait qu'un utilisateur d√©sire jouer
		en ligne contre de vrais joueurs. 
		Il passera par l'inscription et cr√©era son compte sur le
		serveur(Inscription). Une fois cette √©tape obligatoire faite, il choisira
		entre rejoindre une partie en ligne en cour(ConnectionGame), ou en cr√©er un nouvelle(CreateGame).
		D√®s lors qu'il acc√®dera √† une partie en
		ligne, un contact r√©gulier avec le serveur sera obligatoire afin de r√©aliser
		les interactions entre les joueurs(ManageGame). Tout ceci se
		r√©alisera dans une dur√©e infime afin de ne pas p√©naliser les joueurs.	
		
		\begin{figure}
			\includegraphics[scale = 0.5]{Analyse/Img/serveur.eps}
			 \caption {Serveur}
		\end{figure}
		
		\newpage
		
		
	\paragraph{JSON\\}	
	
		Soucieux des performances et de la rapidit√© des √©changes entre applications et
		serveur, nous avons mis en place un protocole de communication client/serveur
		o√π les messages transitant sont des flux \gls{json}. 	
		Contrairement au \gls{xml} qui peut repr√©senter des donn√©es orient√©es document,
		\gls{json} se focalise sur la description d‚Äôobjets.
		Un autre avantage reconnu de \gls{json} par rapport √† \gls{xml} est qu‚Äôil est nettement
		moins verbeux que ce dernier.
		Quoi qu‚Äôil en soit \gls{json} reconnait la philosophie des services web exposant
		une interface d‚Äô√©change : il s‚Äôagit
		d‚Äôenvoyer et de recevoir des informations dans un format facilement manipulable par
		le protocole de transport \gls{http}.
		
		
		Voil√† pourquoi le \gls{json} semblait √™tre un format de donn√©es d'√©changes optimal
		pour v√©hiculer le plus d'informations avec une taille moindre. Il est aussi en
		ad√©quation avec notre politique d'utilisation web pour un serveur.
		De plus √©tant beaucoup utilis√©, nos deux
		langages mettent √† disposition des outils de s√©rialisation de leurs objets en \gls{json}
		
		Ci-dessous un exemple concret de notre protocole de communication \gls{json} entre
		serveur et application cliente.
		
			
		\begin{verbatim}
			ServletInscription
				Player => Serveur
				{["username","password"]}
				
				Serveur => Player
				{"OK"} ou {"BU"}
				
			ServletConnexion 	
				Player => Serveur
				{["username","password"]}
				
				Serveur => Player
				{"OK"} ou {"BU"}
				
			ServletGameList
				Player => Serveur
				{"userKey"}
			
				Serveur => Player
				{[{"class":"Game","map":"mapName","name":"gameName",
				 "playerNumberConnected":nbConnected,"type":"gameType"},{..},{..}]}
				 
			ServletCreateGame:
				Player => Server:
					{"userKey": <userKey>, 
					"game": {"name":<name>, "type":<type>, "map":<map>, "ennemiesNumber": <ennemiesNumber>}}
					
				Server => Player:
					{"OK"} ou {"errorType"}
				 
			ServletConnectionGame:
				Player => Server:
					{["userKey", "gameName"]}
					
				Server => Player:
					{[<1/2/3/4>, "play<true/false>", "map", "time<mm:ss>"]} 
					ou 
					{"errorType"}
					
			ServletManageGame:
				Player => Server: 
					{"userKey", "gameName", "action"}	
					
				Server => Players: (Player, bombs, blocs, score, time)
					{[
					 [ ["x", "y", "direction", "dead <true/false>"],[...] ],
					 [ ["x", "y", "type", "explode <true/false>" ], [...] ],
					 [ ["position": {"x", "y"}, "bonus": <bonus>], [..] ],
					 [1,2,3,4],
					 "time <mm:ss>"]} 
					 ou 
					{"errorType"}
				 
				 
		\end{verbatim}	
		
	

	\subsubsection{Sch√©ma de fonctionnement }
		
		\begin{center}
			\includegraphics[width=16cm]{Analyse/Img/4.eps}
		\end{center}
		
		\begin{enumerate}

			\item 
					Le client √©met une requ√™te pour demander une
					ressource au serveur. Par exemple la cr√©ation de son compte multijoueur,
					qui pourrait se situer \url{http://Bomberklob.com/inscription}
			\item
					C√¥t√© serveur, c'est le serveur web qui traite les
					requ√™tes HTTP entrantes. Il traite donc toutes les requ√™tes, qu'elles
					demandent une ressource statique ou dynamique. Seulement, un serveur HTTP
					ne sait r√©pondre qu'aux requ√™tes visant des ressources statiques.

			\item 
					Ainsi, si le serveur HTTP s'aper√ßoit que la requ√™te re√ßue est destin√©e
					au serveur d'applications, il la lui transmet. Les deux serveurs sont
					reli√©s par un canal, nomm√© connecteur.
		
			\item
					Le serveur d'applications (dans notre cas Tomcat) re√ßoit la requ√™te √†
					son tour. Lui est en mesure de la traiter. Il ex√©cute donc la servlet
					correspondante √† la requ√™te, en fonction de l'URL, en r√©cup√©rant les
					valeurs dans le flux JSON entrant. Cette op√©ration est effectu√©e √† partir
					de la configuration du serveur, gr√¢ce un fichier web.xml faisant le mapping
					entre URL et servlet associ√©e.
		
					La servlet est donc invoqu√©e, et le serveur lui fournit notamment deux
					objets Java exploitables: un repr√©sentant la requ√™te, l'autre repr√©sentant
					la r√©ponse. La servlet execute sa fonction et g√©n√®re la r√©ponse √† la
					demande, sous forme de flux JSON. Cela peut passer par la consultation de
					sources de donn√©es, comme des bases de donn√©es (4' sur le sch√©ma).		
		
		\end{enumerate}
		
	\paragraph{Base de donn√©es\\}
		Afin de pouvoir conserver les utilisateurs en ligne ainsi que leurs infos
		personnels et permettre une authentification, nous avons d√ª √©tablir une
		base de donn√©es sur le serveur. Cette derni√®re √† √©t√© pens√© comme demand√© pour 
		l'enregistrement de comptes. Une unique table nomm√©e Users remplie donc cette
		fonction. Le serveur devra pouvoir y acc√©der en √©criture(inscription) comme
		en lecture(connexion).
			Al√©atoire
		Elle ne comportera que deux champs, userName et password. D√®s lors que
		l'utilisateur d√©sirera cr√©er un compte multijoueur, il renseignera dans
		l'application son userName souhait√© ainsi que son mot de passe. 
		Ce couple sera 	alors envoy√© au serveur qui v√©rifiera dans cette base de
		donn√©es, que le userName(unique) n'est pas d√©j√† utilis√©. Auquel cas un nouveau n-uplet sera
		ins√©r√© et permettra l'authentification de l'utilisateur par la suite. Les mots
		de passe seront bien √©videment crypt√© pour des raisons de s√©curit√©.
			

		\newpage
		
	
